type AccessToken implements Node {
  accountId: ID
  createdAt: DateTime!
  graphScopes: [Graph!]!
  id: ID!
  name: String!
}

type AccessTokenConnection {
  edges: [AccessTokenEdge!]!
  nodes: [AccessToken!]!
  pageInfo: PageInfo!
}

input AccessTokenCreateInput {
  name: String!
  accountId: ID
  graphScopes: [ID!]
  kind: AccessTokenKind! = USER
  projectScopes: [ID!]
}

union AccessTokenCreatePayload = AccessTokenCreateSuccess | CouldNotFindGraphsError | CouldNotFindProjectsError | GraphScopeLimitExceededError | InvalidAccountError | ProjectScopeLimitExceededError | TokenLimitExceededError

type AccessTokenCreateSuccess {
  jwt: String!
  query: Query!
  token: AccessToken!
}

input AccessTokenDeleteInput {
  id: ID!
}

union AccessTokenDeletePayload = AccessTokenDeleteSuccess | TokenDoesNotExistError

type AccessTokenDeleteSuccess {
  deletedId: ID!
  query: Query!
}

type AccessTokenEdge {
  cursor: String!
  node: AccessToken!
}

enum AccessTokenKind {
  USER
  ACCOUNT
}

interface Account {
  accessTokens(after: String, before: String, first: Int, last: Int): AccessTokenConnection!
  createdAt: DateTime!
  graphs(after: String, before: String, first: Int, last: Int): GraphConnection!
  graphsCountStatus: ResourceStatus!
  id: ID!
  name: String!
  plan: GrafbasePlan!
  resources: AccountResources!
  resourcesUsageDashboard(filter: AccountResourcesUsageDashboardFilter): AccountResourcesUsageDashboardPayload!
  slug: String!
  status: AccountStatus!
}

input AccountCreationValidateInput {
  slug: String!
}

type AccountCreationValidatePayload {
  slugAvailable: Boolean!
}

type AccountDoesNotExistError {
  query: Query!
}

type AccountDopplerIntegration {
  accessToken: String!
}

input AccountDopplerIntegrationInput {
  accessToken: String!
}

type AccountIntegration {
  accountId: ID!
  attributes: AccountIntegrationAttributes!
  createdAt: DateTime!
  enabled: Boolean!
  environments: [BranchEnvironment!]!
  graphs: [GraphIntegration!]!
  id: ID!
  integrationId: ID!
}

union AccountIntegrationAttributes = AccountDopplerIntegration | DatadogIntegration

input AccountIntegrationAttributesInput {
  datadog: DatadogIntegrationInput
  doppler: AccountDopplerIntegrationInput
}

input AccountIntegrationInput {
  graphs: [ID!]
  enabled: Boolean!
  environments: [BranchEnvironment!]
  attributes: AccountIntegrationAttributesInput!
}

type AccountIntegrationMutationError {
  message: String!
  query: Query!
}

union AccountIntegrationMutationPayload = AccountIntegrationMutationError | AccountIntegrationMutationSuccess

type AccountIntegrationMutationSuccess {
  account: Account!
  query: Query!
}

type AccountResources {
  graphs: ResourceStatus!
}

type AccountResourcesStatus {
  buildDuration: ResourceStatus!
  execUnits: ResourceStatus!
  requestCount: ResourceStatus!
  udfExecUnits: ResourceStatus!
  udfRequestCount: ResourceStatus!
}

type AccountResourcesUsage {
  buildDuration: TimeSeries! @deprecated(reason: "to be removed soon")
  execUnits: TimeSeries!
  granularity: TimeAggregationGranularity!
  requestCount: TimeSeries!
  serverlessFunctionDuration: TimeSeries! @deprecated(reason: "to be removed soon")
  serverlessFunctionInvocationCount: TimeSeries! @deprecated(reason: "to be removed soon")
  udfExecUnits: TimeSeries! @deprecated(reason: "to be removed soon")
  udfRequestCount: TimeSeries! @deprecated(reason: "to be removed soon")
}

"""

'limit_cycle_choice' is exclusive with all other options. It's the only case
where we'll show account limit status (used/limit)

"""
input AccountResourcesUsageDashboardFilter {
  projectIds: [ID!]
  graphIds: [ID!]
  limitCycleChoice: LimitCycleChoice
  startDate: DateTime
  endDate: DateTime
}

type AccountResourcesUsageDashboardInvalidFilterCombinationError {
  message: String!
  query: Query!
}

union AccountResourcesUsageDashboardPayload = AccountResourcesUsageDashboardInvalidFilterCombinationError | AccountResourcesUsageDashboardSuccess

type AccountResourcesUsageDashboardSuccess {
  periodEnd: DateTime!
  periodStart: DateTime!
  status: AccountResourcesStatus
  usage: AccountResourcesUsage!
}

type AccountStatus {
  hasExceededLimits: Boolean!
  inArrearsCause: InArrearsCause
  isEnabled: Boolean!
  isHobbyPlanEnforced: Boolean!
}

type AlreadyMemberError {
  query: Query!
}

type ArchiveFileSizeLimitExceededError {
  limit: Int!
  query: Query!
}

type Branch implements Node {
  activeDeployment: Deployment
  deployments(after: String, before: String, first: Int, last: Int): DeploymentConnection!
  domains: [String!]!
  endpointConfig: EndpointConfig
  environment: BranchEnvironment!
  federatedSchema: String
  graph: Graph!
  id: ID!
  latestDeployment: Deployment
  name: String!
  operationChecksEnabled: Boolean!
  schema: String
  schemaProposals(after: String, first: Int, filter: SchemaProposalFilter!): SchemaProposalConnection!
  subgraphs: [Subgraph!]!
}

type BranchAlreadyExistsError {
  query: Query!
}

type BranchConnection {
  edges: [BranchEdge!]!
  nodes: [Branch!]!
  pageInfo: PageInfo!
}

input BranchCreateInput {
  accountSlug: String!
  graphSlug: String!
  branchName: String!
}

union BranchCreatePayload = BranchAlreadyExistsError | GraphDoesNotExistError | GraphNotSelfHostedError | Query

union BranchDeletePayload = BranchDoesNotExistError | CannotDeleteProductionBranchError | Query

type BranchDoesNotExistError {
  query: Query!
}

type BranchEdge {
  cursor: String!
  node: Branch!
}

enum BranchEnvironment {
  PREVIEW
  PRODUCTION
}

type BranchNotDeployedError {
  query: Query!
}

input BranchUpdateInput {
  operationChecksEnabled: Boolean
  accountSlug: String!
  graphSlug: String
  projectSlug: String
  branchSlug: String!
  trustedDocumentsEnforce: Boolean
  trustedDocumentsBypassHeaderName: String
  trustedDocumentsBypassHeaderValue: String
}

union BranchUpdatePayload = GraphDoesNotExistError | ProjectDoesNotExistError | Query

type CannotBeRenamedError {
  query: Query!
}

type CannotDeleteProductionBranchError {
  query: Query!
}

type CannotUseInvitationsWithSSO {
  query: Query!
}

type CompositionCheckError {
  message: String!
  title: String!
}

type CouldNotFindGraphsError {
  unknownGraphIds: [ID!]!
}

type CouldNotFindProjectsError {
  unknownProjectIds: [ID!]!
}

type CurrentPlanLimitReachedError {
  max: Int!
  query: Query!
}

type CustomDomain {
  branch: String!
  hostnameVerificationStatus: CustomDomainStatus!
  hostnameVerificationTxtName: String
  hostnameVerificationTxtValue: String
  name: String!
  sslVerificationCnameName: String
  sslVerificationCnameValue: String
  sslVerificationStatus: CustomDomainStatus!
}

type CustomDomainAlreadyExistsError {
  query: Query!
}

input CustomDomainCreateInput {
  name: String!
  branch: String!
  projectId: ID
  graphId: ID
}

union CustomDomainCreatePayload = BranchDoesNotExistError | BranchNotDeployedError | CustomDomainAlreadyExistsError | CustomDomainCreateSuccess | GraphDoesNotExistError | InvalidDomainError | OperationNotAllowedByPlanError | ProjectDoesNotExistError | TooManyCustomDomainsError

type CustomDomainCreateSuccess {
  domain: CustomDomain!
  query: Query!
}

input CustomDomainDeleteInput {
  name: String!
  projectId: ID
  graphId: ID
}

union CustomDomainDeletePayload = CustomDomainDeleteSuccess | CustomDomainDoesNotExistError

type CustomDomainDeleteSuccess {
  name: String!
  query: Query!
}

type CustomDomainDoesNotExistError {
  query: Query!
}

input CustomDomainReplaceInput {
  name: String!
  branch: String!
  projectId: ID
  graphId: ID
  existingName: String!
}

union CustomDomainReplacePayload = BranchDoesNotExistError | BranchNotDeployedError | CustomDomainDoesNotExistError | CustomDomainReplaceSuccess | GraphDoesNotExistError | InvalidDomainError | OperationNotAllowedByPlanError | ProjectDoesNotExistError

type CustomDomainReplaceSuccess {
  domain: CustomDomain!
  query: Query!
}

enum CustomDomainStatus {
  ACTIVE
  PENDING
  ERROR
}

type DailyDeploymentCountLimitExceededError {
  limit: Int!
  query: Query!
}

type DatadogIntegration {
  apiKey: String!
  environments: [BranchEnvironment!]!
  region: DatadogRegion!
  sampling: Int!
}

input DatadogIntegrationInput {
  apiKey: String!
  region: DatadogRegion!
  sampling: Int!
}

enum DatadogRegion {
  US1
  US3
  US5
  EU1
  US1_FED
  AP1
}

scalar DateTime

input DeleteSubgraphInput {
  message: String
  accountSlug: String!
  graphSlug: String
  projectSlug: String
  branch: String!
  subgraph: String!
  dryRun: Boolean!
}

union DeleteSubgraphPayload = DeleteSubgraphSuccess | FederatedGraphCompositionError | GraphBranchDoesNotExistError | GraphDoesNotExistError | GraphNotFederatedError | ProjectBranchDoesNotExistError | ProjectDoesNotExistError | ProjectNotFederatedError | SubgraphNotFoundError

type DeleteSubgraphSuccess {
  query: Query!
}

type Deployment implements Node {
  branch: Branch!
  commit: GitCommit
  createdAt: DateTime!
  diffAgainstLatestProductionDeployment: String
  diffAgainstPreviousBranchDeployment: String
  duration: Int
  finishedAt: DateTime
  graph: Graph!
  id: ID!
  isRedeployable: Boolean!
  logEntries: [DeploymentLogEntry!]!
  schema: String
  startedAt: DateTime
  status: DeploymentStatus!
  triggerType: DeploymentTriggerType!
}

input DeploymentBySlugCreateInput {
  accountSlug: String!
  graphSlug: String
  projectSlug: String
  branch: String
  archiveFileSize: Int!
}

type DeploymentConnection {
  edges: [DeploymentEdge!]!
  nodes: [Deployment!]!
  pageInfo: PageInfo!
}

input DeploymentCreateInput {
  branch: String
  projectId: ID
  graphId: ID
  archiveFileSize: Int!
}

union DeploymentCreatePayload = ArchiveFileSizeLimitExceededError | DailyDeploymentCountLimitExceededError | DeploymentCreateSuccess | GraphDoesNotExistError | GraphNotManagedError | GraphNotStandaloneError | NotAllowedError | ProjectDoesNotExistError | ProjectNotManagedError | ProjectNotStandaloneError

type DeploymentCreateSuccess {
  deployment: Deployment!
  presignedUrl: String!
  query: Query!
}

type DeploymentDoesNotExistError {
  query: Query!
}

type DeploymentEdge {
  cursor: String!
  node: Deployment!
}

input DeploymentFilter {
  branch: String
  statuses: [DeploymentStatus!]
}

type DeploymentLogEntry {
  createdAt: DateTime!
  level: DeploymentLogLevel!
  message: String!
}

enum DeploymentLogLevel {
  ERROR
  WARN
  INFO
}

union DeploymentRedeployPayload = DailyDeploymentCountLimitExceededError | DeploymentDoesNotExistError | DeploymentRedeploySuccess | NotAllowedError

type DeploymentRedeploySuccess {
  deployment: Deployment!
  query: Query!
}

enum DeploymentStatus {
  QUEUED
  IN_PROGRESS
  SUCCEEDED
  FAILED
}

enum DeploymentTriggerType {
  GRAPH_CREATION
  PROJECT_CREATION @deprecated(reason: "replaced by GraphCreation")
  GIT_PUSH
  CLI
  REDEPLOYMENT
  NEW_SCHEMA_PUBLICATION
  INTERNAL
}

type DiffSnippet {
  addedLines: [Int!]!
  originalSchemaSnippet: String!
  originalSchemaSnippetFirstLine: Int!
  proposedSchemaSnippet: String!
  proposedSchemaSnippetFirstLine: Int!
  removedLines: [Int!]!
}

type DisabledAccountError {
  query: Query!
}

type DopplerConfig {
  name: String!
  projectName: String!
}

type DopplerProject {
  name: String!
}

type DuplicateDatabaseRegionsError {
  duplicates: [String!]!
  query: Query!
}

scalar Duration

input DurationFilter {
  lt: Duration
  lte: Duration
  gt: Duration
  gte: Duration
}

type EmptyDatabaseRegionsError {
  query: Query!
}

type EndpointConfig {
  url: String!
}

input EndpointConfigInput {
  url: String!
}

input EndpointConfigUpdateInput {
  endpointConfig: EndpointConfigInput!
  accountSlug: String!
  graphSlug: String!
  branchSlug: String!
}

union EndpointConfigUpdatePayload = GraphDoesNotExistError | Query

input EnviromentVariableUpsertInput {
  name: String!
  environments: [BranchEnvironment!]!
  accountSlug: String!
  graphSlug: String
  projectSlug: String
  value: String!
  sensitive: Boolean
}

type EnvironmentVariable implements Node {
  branches: [String!]
  createdAt: DateTime!
  environments: [BranchEnvironment!]!
  id: ID!
  name: String!
  updatedAt: DateTime!
  value: String!
}

type EnvironmentVariableConnection {
  edges: [EnvironmentVariableEdge!]!
  nodes: [EnvironmentVariable!]!
  pageInfo: PageInfo!
}

type EnvironmentVariableCountLimitExceededError {
  query: Query!
}

input EnvironmentVariableCreateInput {
  """
  
      Must not be already assigned.
      
  """
  name: String!
  environments: [BranchEnvironment!]!
  projectId: ID
  graphId: ID
  value: String!
  sensitive: Boolean
}

union EnvironmentVariableCreatePayload = EnvironmentVariableCreateSuccess | GraphDoesNotExistError | NameAlreadyExistsError | NameContainsInvalidCharactersError | NameTooLongError | NoEnvironmentsSetError | ProjectDoesNotExistError | ReservedPrefixError | ValueTooLongError

type EnvironmentVariableCreateSuccess {
  environmentVariable: EnvironmentVariable!
  query: Query!
}

input EnvironmentVariableDeleteByValuesInput {
  name: String!
  environments: [BranchEnvironment!]!
  projectId: ID
  graphId: ID
}

union EnvironmentVariableDeleteByValuesPayload = EnvironmentVariableDeleteByValuesSuccess | EnvironmentVariableDoesNotExistError

input EnvironmentVariableDeleteByValuesSlugsInput {
  name: String!
  environments: [BranchEnvironment!]!
  accountSlug: String!
  graphSlug: String
  projectSlug: String
}

type EnvironmentVariableDeleteByValuesSuccess {
  query: Query!
}

input EnvironmentVariableDeleteInput {
  id: ID!
}

union EnvironmentVariableDeletePayload = EnvironmentVariableDeleteSuccess | EnvironmentVariableDoesNotExistError

type EnvironmentVariableDeleteSuccess {
  deletedId: ID!
  query: Query!
}

type EnvironmentVariableDoesNotExistError {
  query: Query!
}

type EnvironmentVariableEdge {
  cursor: String!
  node: EnvironmentVariable!
}

input EnvironmentVariableSpecification {
  name: String!
  value: String!
  sensitive: Boolean
}

input EnvironmentVariableUpdateInput {
  id: ID!
  name: String
  environments: [BranchEnvironment!]
  value: String
}

union EnvironmentVariableUpdatePayload = EnvironmentVariableDoesNotExistError | EnvironmentVariableUpdateSuccess | NameAlreadyExistsError | NameContainsInvalidCharactersError | NameTooLongError | NoEnvironmentsSetError | ReservedPrefixError | ValueTooLongError

type EnvironmentVariableUpdateSuccess {
  environmentVariable: EnvironmentVariable!
  query: Query!
}

type ErrorCountByCode {
  code: String!
  count: Int!
}

type FederatedGraphCompositionError {
  messages: [String!]!
  query: Query!
}

type FieldAnalytics {
  metrics: FieldMetricsTimeSeries
  topClients(limit: Int, searchQuery: String): TopClientsForField
}

type FieldMetrics {
  count: Int!
}

type FieldMetricsTimeSeries {
  overall: FieldMetrics!
  points: [FieldMetricsTimeSeriesDataPoint!]!
  previousPeriod: FieldMetricsTimeSeries
}

type FieldMetricsTimeSeriesDataPoint {
  count: Int!
  dateTime: DateTime!
}

enum FunctionKind {
  AUTHORIZER
  RESOLVER
}

type FunctionLogEvent implements LogEvent {
  branch: String!
  createdAt: DateTime!
  deploymentId: ID!
  environment: BranchEnvironment!
  functionKind: FunctionKind!
  functionName: String!
  id: String!
  logLevel: LogLevel!
  message: String!
  region: String!
  url: String
}

type GatewayRequestLogEvent implements LogEvent {
  branch: String!
  createdAt: DateTime!
  deploymentId: ID!
  duration: Int!
  environment: BranchEnvironment!
  httpMethod: String!
  httpStatus: Int!
  id: String!
  logLevel: LogLevel!
  message: String!
  operation: GatewayRequestLogEventOperation
  region: String!
  url: String!
}

type GatewayRequestLogEventOperation {
  name: String
  type: OperationType!
}

type GitAccount {
  connectedAt: DateTime!
  id: ID!
  provider: GitProvider!
  slug: String!
  type: GitAccountType!
}

union GitAccountsPayload = GitAccountsSuccess | GitHubAuthorizationError

type GitAccountsSuccess {
  accounts: [GitAccount!]!
  query: Query!
}

enum GitAccountType {
  ORGANIZATION
  PERSONAL
}

type GitCommit {
  author: String
  authorAvatarUrl: String
  message: String!
  sha: String!
}

type GithubApiError {
  error: GithubApiErrorKind!
  query: Query!
}

enum GithubApiErrorKind {
  ERROR
  CONNECTION
  STATUS
  DECODE
  UNKNOWN
}

type GitHubAuthorizationError {
  query: Query!
}

type GithubInstallationInsufficientPermissionsError {
  query: Query!
}

input GithubUserTokenUpdateE2EInput {
  token: String!
}

union GithubUserTokenUpdateE2EPayload = GithubUserTokenUpdateE2ESuccess

type GithubUserTokenUpdateE2ESuccess {
  query: Query!
}

input GithubUserTokenUpdateInput {
  code: String!
}

union GithubUserTokenUpdatePayload = GithubApiError | GithubUserTokenUpdateSuccess

type GithubUserTokenUpdateSuccess {
  query: Query!
}

enum GitProvider {
  GITHUB
}

type GitRepository {
  branches: [String!]!
  defaultBranch: String
  id: String!
  owner: String!
  private: Boolean!
  provider: GitProvider!
  slug: String!
  updatedAt: DateTime!
  url: String!
}

enum GrafbasePlan {
  HOBBY @deprecated(reason: "to be removed soon")
  PRO @deprecated(reason: "to be removed soon")
  TRIAL
  ENTERPRISE
}

type Graph implements Node {
  account: Account!
  analytics(filters: GraphAnalyticsFilters!): GraphAnalytics
  apiKeys(after: String, before: String, first: Int, last: Int): GraphApiKeyConnection!
  branches(after: String, before: String, first: Int, last: Int): BranchConnection!
  canBeRenamed: Boolean!
  createdAt: DateTime!
  customDomains: [CustomDomain!]!
  deployments(after: String, before: String, first: Int, last: Int, filter: DeploymentFilter): DeploymentConnection!
  environmentVariables(after: String, before: String, first: Int, last: Int): EnvironmentVariableConnection!
  graphMode: GraphMode!
  graphType: GraphType
  id: ID!
  logEvents(after: String, before: String, first: Int, last: Int, filter: LogEventFilter!): LogEventConnection!
  operationChecksConfiguration: GraphOperationCheckConfiguration!
  owners: [Team!]!
  productionBranch: Branch!
  repoRootPath: String!
  repository: GitRepository
  request(branchName: String, approximateTimestamp: DateTime!, traceId: ID!): Request
  requestAnalytics(filter: GraphRequestAnalyticsFilter!): RequestAnalytics @deprecated(reason: "Use `analytics` instead")
  requests(after: String, before: String, first: Int, last: Int, filters: RequestFilters!): RequestConnection
  schemaChecks(after: String, first: Int, branch: String): SchemaCheckConnection!
  schemaProposals(after: String, first: Int): SchemaProposalConnection!
  slug: String!
  status: GraphStatus!
}

union GraphAddOwnerPayload = GraphAddOwnerSuccess | GraphDoesNotExistError | NotAllowedError

type GraphAddOwnerSuccess {
  query: Query!
}

type GraphAnalytics {
  forField(schemaPath: String!): FieldAnalytics!
  requestMetrics(latencyPercentiles: [Float!]): RequestMetricsTimeSeriesV2
  topClients(limit: Int, searchQuery: String, latencyPercentile: Float): TopClients
  topOperations(limit: Int, searchQuery: String, latencyPercentile: Float): TopOperations
}

input GraphAnalyticsFilters {
  """
  
      Defaults to production branch
      
  """
  branchName: String

  """
  
      Use this if you really care about having a specific duration like 1 hour, 7 days, etc.
      
  """
  range: Duration

  """
  
      Use this if you *at least* the data between `from` and `to` to be provided. You may get
      more, but never less.
      
  """
  from: DateTime

  """
  
      To be used in conjunction with with either `range` or `from`.
      
  """
  to: DateTime!

  """
  
      If explicitly to false, specifying both `from` and `to` will be treated as if `range: (to - from)`
      had been specified instead. Meaning only the duration between `from` and `to` matters, not
      necessarily having a data point for `from` itself.
      
  """
  isCustomRange: Boolean

  """
  
      If specified, overrides approximateNumberOfPoints. Must be in whole minutes.
      At most 150 points can be returned.
      
  """
  aggregationStep: Duration

  """
  
      Defaults to 100, at most 150 points can be returned.
      
  """
  approximateNumberOfDataPoints: Int

  """
  
      Defaults to true
      Example: for an aggregationStep of 15 min:
      - if true, only times with 00, 15, 30 and 45 minutes will appear in the time series
      - if false, times in the time series will be adjusted to start from the periodStart (~from).
      So if from = 15:32:00, times will end in 02, 17, 32 and 47.
      I'll always align to the aggregation step used to store the data though, which
      is currently in minutes. So cannot have 15:10:20, 15:11:20, etc.
      
  """
  alignPeriodWithAggregationStep: Boolean
  operationName: String

  """
  
      Only used if operation name is specified.
      
  """
  operationNormalizedQueryHash: OperationNormalizedQueryHash
  clientName: String

  """
  
      Only used if client name is specified.
      
  """
  clientVersion: String
}

type GraphApiKey implements Node {
  createdAt: DateTime!
  environment: BranchEnvironment!
  id: ID!
  key: String!
  name: String!
}

type GraphApiKeyConnection {
  edges: [GraphApiKeyEdge!]!
  nodes: [GraphApiKey!]!
  pageInfo: PageInfo!
}

input GraphApiKeyCreateInput {
  name: String!
  environment: BranchEnvironment!
  graphId: ID!
}

union GraphApiKeyCreatePayload = GraphApiKeyCreateSuccess | GraphDoesNotExistError | KeyLimitExceededError

type GraphApiKeyCreateSuccess {
  apiKey: GraphApiKey!
  query: Query!
}

input GraphApiKeyDeleteInput {
  id: ID!
}

union GraphApiKeyDeletePayload = GraphApiKeyDeleteSuccess | KeyDoesNotExistError | MustLeaveAtLeastOneKeyForEnvironmentError

type GraphApiKeyDeleteSuccess {
  deletedId: ID!
  query: Query!
}

type GraphApiKeyEdge {
  cursor: String!
  node: GraphApiKey!
}

input GraphApiKeyUpdateInput {
  id: ID!
  name: String!
}

union GraphApiKeyUpdatePayload = GraphApiKeyUpdateSuccess | KeyDoesNotExistError

type GraphApiKeyUpdateSuccess {
  query: Query!
}

type GraphBranchDoesNotExistError {
  query: Query!
}

type GraphConnection {
  edges: [GraphEdge!]!
  nodes: [Graph!]!
  pageInfo: PageInfo!
}

input GraphCreateFromRepositoryInput {
  accountId: ID!
  graphSlug: String!
  repoRootPath: String! = "grafbase"
  productionBranch: String!
  environmentVariables: [EnvironmentVariableSpecification!]! = []
  gitRepoUrl: Url!
  gitAccountId: String!
}

union GraphCreateFromRepositoryPayload = AccountDoesNotExistError | CurrentPlanLimitReachedError | DisabledAccountError | DuplicateDatabaseRegionsError | EmptyDatabaseRegionsError | EnvironmentVariableCountLimitExceededError | GraphCreateFromRepositorySuccess | InvalidDatabaseRegionsError | InvalidEnvironmentVariablesError | InvalidRepoRootPathError | RepositoryContainsNoBranchesError | SlugAlreadyExistsError | SlugInvalidError | SlugTooLongError

type GraphCreateFromRepositorySuccess {
  graph: Graph!
  query: Query!
}

input GraphCreateFromSchemaInput {
  accountId: ID!
  schema: String!
  graphSlug: String!
  environmentVariables: [EnvironmentVariableSpecification!]! = []
}

union GraphCreateFromSchemaPayload = AccountDoesNotExistError | CurrentPlanLimitReachedError | DisabledAccountError | DuplicateDatabaseRegionsError | EmptyDatabaseRegionsError | EnvironmentVariableCountLimitExceededError | GraphCreateFromSchemaSuccess | InvalidDatabaseRegionsError | InvalidEnvironmentVariablesError | SlugAlreadyExistsError | SlugInvalidError | SlugTooLongError

type GraphCreateFromSchemaSuccess {
  graph: Graph!
  query: Query!
}

input GraphCreateFromTemplateInput {
  accountId: ID!
  graphSlug: String!
  repoRootPath: String! = "grafbase"
  environmentVariables: [EnvironmentVariableSpecification!]! = []
  gitAccountId: String!
  templateGitUrl: Url!
  repoSlug: String!
  repoPrivate: Boolean!
}

union GraphCreateFromTemplatePayload = AccountDoesNotExistError | CurrentPlanLimitReachedError | DisabledAccountError | DuplicateDatabaseRegionsError | EmptyDatabaseRegionsError | EnvironmentVariableCountLimitExceededError | GithubInstallationInsufficientPermissionsError | GraphCreateFromTemplateSuccess | InvalidDatabaseRegionsError | InvalidEnvironmentVariablesError | InvalidRepoRootPathError | RepositorySlugInUseError | SlugAlreadyExistsError | SlugInvalidError | SlugTooLongError | TemplateDoesNotExistError

type GraphCreateFromTemplateSuccess {
  graph: Graph!
  query: Query!
}

input GraphCreateInput {
  accountId: ID!
  graphSlug: String!
  repoRootPath: String! = "grafbase"
  graphType: GraphType
  graphMode: GraphMode! = MANAGED
  environmentVariables: [EnvironmentVariableSpecification!]! = []
}

union GraphCreatePayload = AccountDoesNotExistError | CurrentPlanLimitReachedError | DisabledAccountError | DuplicateDatabaseRegionsError | EmptyDatabaseRegionsError | EnvironmentVariableCountLimitExceededError | GraphCreateSuccess | InvalidDatabaseRegionsError | InvalidEnvironmentVariablesError | InvalidRepoRootPathError | SlugAlreadyExistsError | SlugInvalidError | SlugTooLongError | StandaloneGraphsNoLongerSupportedError

type GraphCreateSuccess {
  graph: Graph!
  query: Query!
}

input GraphDeleteInput {
  id: ID!
}

union GraphDeletePayload = GraphDeleteSuccess | GraphDoesNotExistError

type GraphDeleteSuccess {
  query: Query!
}

type GraphDoesNotExistError {
  query: Query!
}

input GraphDopplerIntegrationAttributesInput {
  projectName: String!
  configName: String!
}

type GraphEdge {
  cursor: String!
  node: Graph!
}

type GraphIntegration {
  accountIntegrationId: ID!
  attributes: GraphIntegrationAttributes
  branch: Branch
  createdAt: DateTime!
  enabled: Boolean!
  graph: Graph!
  id: ID!
}

union GraphIntegrationAttributes = ProjectDopplerIntegration

input GraphIntegrationAttributesInput {
  doppler: GraphDopplerIntegrationAttributesInput
}

input GraphIntegrationInput {
  enabled: Boolean!
  attributes: GraphIntegrationAttributesInput
  branch: ID
}

type GraphIntegrationMutationError {
  message: String!
  query: Query!
}

union GraphIntegrationMutationPayload = GraphIntegrationMutationError | GraphIntegrationMutationSuccess

type GraphIntegrationMutationSuccess {
  account: Account!
  query: Query!
}

enum GraphMode {
  MANAGED @deprecated(reason: "to be removed soon")
  SELF_HOSTED
}

type GraphNotFederatedError {
  query: Query!
}

type GraphNotManagedError {
  query: Query!
}

type GraphNotSelfHostedError {
  query: Query!
}

type GraphNotStandaloneError {
  query: Query!
}

type GraphOperationCheckConfiguration {
  excludedClients: [String!]!
  excludedOperations: [String!]!
  requestCountThreshold: Int!
  timeRangeDays: Int!
}

input GraphOperationCheckConfigurationInput {
  """
  
      Whether operation checks are enabled for the graph. This is ignored, since
  operation checks are now only enabled at the branch level.
      
  """
  enabled: Boolean

  """
  
      The graph to update.
      
  """
  graphId: ID!

  """
  
      The time range in days to consider for operation checks. Operations older than the specificied
      number of days are ignored.
      
  """
  timeRangeDays: Int

  """
  
      The request count threshold to consider for operation checks. Operations that have been
      registered less than the specified number of occurrences are ignored.
      
  """
  requestCountThreshold: Int

  """
  
      The clients to exclude from operation checks.
      
  """
  excludedClients: [String!]

  """
  
      The operations to exclude from operation checks.
      
  """
  excludedOperations: [String!]
}

union GraphOperationCheckConfigurationUpdatePayload = GraphDoesNotExistError | GraphOperationCheckConfiguration | NotAllowedError

union GraphRemoveOwnerPayload = GraphDoesNotExistError | GraphRemoveOwnerSuccess | NotAllowedError

type GraphRemoveOwnerSuccess {
  query: Query!
}

input GraphRequestAnalyticsFilter {
  branch: String = null
  from: DateTime
  to: DateTime
  aggregationStep: Duration
  approximateNumberOfDataPoints: Int
  alignPeriodWithAggregationStep: Boolean
  clientName: String
  clientVersion: String
  period: GraphRequestAnalyticsPeriod
  now: DateTime
  graphqlOperation: String
  operationId: ID
}

enum GraphRequestAnalyticsPeriod {
  LAST_HOUR
  LAST_24_HOURS
  LAST_7_DAYS
}

type GraphScopeLimitExceededError {
  query: Query!
}

enum GraphStatus {
  ACTIVE
  INACTIVE
}

enum GraphType {
  STANDALONE @deprecated(reason: "to be removed soon")
  FEDERATED
}

input GraphUpdateInput {
  id: ID!
  graphSlug: String
  repoRootPath: String
  productionBranch: String
}

union GraphUpdatePayload = CannotBeRenamedError | GraphDoesNotExistError | GraphUpdateSuccess | NotAllowedError | SlugAlreadyExistsError | SlugInvalidError | SlugTooLongError

type GraphUpdateSuccess {
  graph: Graph!
  query: Query!
}

type HasAlreadyPaymentMethodError {
  query: Query!
}

enum InArrearsCause {
  NEVER_PAID
  UNPAID_INVOICE
}

type Integration {
  createdAt: DateTime!
  id: ID!
  name: String!
}

type InvalidAccountError {
  query: Query!
}

type InvalidDatabaseRegionsError {
  invalid: [String!]!
  query: Query!
}

type InvalidDomainError {
  query: Query!
}

type InvalidEnvironmentVariableError {
  error: InvalidEnvironmentVariableErrorType!
  variableName: String!
}

enum InvalidEnvironmentVariableErrorType {
  NAME_TOO_LONG
  NAME_CONTAINS_INVALID_CHARACTERS
  VALUE_TOO_LONG
  RESERVED_PREFIX
  DUPLICATE
  NO_ENVIRONMENTS_SET
}

type InvalidEnvironmentVariablesError {
  errors: [InvalidEnvironmentVariableError!]!
}

type InvalidRepoRootPathError {
  query: Query!
}

type Invite implements Node {
  createdAt: DateTime!
  email: String!
  id: ID!
  invitedBy: User!
  lastRenewedAt: DateTime!
  organization: Organization!
  role: MemberRole!
  status: InviteStatus!
}

input InviteAcceptInput {
  id: ID!
}

union InviteAcceptPayload = AlreadyMemberError | CannotUseInvitationsWithSSO | InviteAcceptSuccess | InviteDoesNotExistError

type InviteAcceptSuccess {
  member: Member!
  query: Query!
}

input InviteCancelInput {
  id: ID!
}

union InviteCancelPayload = InviteCancelSuccess | InviteDoesNotExistError | NotAllowedToCancelInvitesError

type InviteCancelSuccess {
  inviteId: ID!
  query: Query!
}

type InviteConnection {
  edges: [InviteEdge!]!
  nodes: [Invite!]!
  pageInfo: PageInfo!
}

input InviteDeclineInput {
  id: ID!
}

union InviteDeclinePayload = InviteDeclineSuccess | InviteDoesNotExistError

type InviteDeclineSuccess {
  inviteId: ID!
  query: Query!
}

type InviteDoesNotExistError {
  query: Query!
}

type InviteEdge {
  cursor: String!
  node: Invite!
}

input InviteSendInput {
  role: MemberRole!
  email: String!
  organizationId: ID!
}

union InviteSendPayload = CannotUseInvitationsWithSSO | InviteSendSuccess | NotAllowedToSendInvitesError | OrganizationDoesNotExistError

type InviteSendSuccess {
  invite: Invite!
  query: Query!
}

enum InviteStatus {
  PENDING
  EXPIRED
}

scalar JSON

type KeyDoesNotExistError {
  query: Query!
}

type KeyLimitExceededError {
  query: Query!
}

enum LimitCycleChoice {
  CURRENT
  PREVIOUS
}

type LintCheckError {
  message: String!
  severity: SchemaCheckErrorSeverity!
  title: String!
}

interface LogEvent {
  branch: String!
  createdAt: DateTime!
  deploymentId: ID!
  environment: BranchEnvironment!
  id: String!
  logLevel: LogLevel!
  message: String!
  region: String!
}

type LogEventConnection {
  edges: [LogEventEdge!]!
  nodes: [LogEvent!]!
  pageInfo: PageInfo!
}

type LogEventEdge {
  cursor: String!
  node: LogEvent!
}

input LogEventFilter {
  query: String
  branch: String
  region: [String!]
  logLevel: [LogLevel!]
  from: DateTime
  to: DateTime
}

enum LogLevel {
  ERROR
  WARN
  INFO
  DEBUG
}

type Member implements Node {
  account: Account!
  createdAt: DateTime!
  id: ID!
  role: MemberRole!
  user: User!
}

type MemberConnection {
  edges: [MemberEdge!]!
  nodes: [Member!]!
  pageInfo: PageInfo!
}

input MemberDeleteInput {
  id: ID!
}

type MemberDeletePayload {
  deletedMemberId: ID!
  query: Query!
}

type MemberEdge {
  cursor: String!
  node: Member!
}

enum MemberRole {
  OWNER
  MEMBER
  ADMIN
}

input MemberUpdateInput {
  id: ID!
  role: MemberRole
}

type MemberUpdatePayload {
  member: Member!
  query: Query!
}

type MissingStripeCustomerError {
  query: Query!
}

type MustLeaveAtLeastOneKeyForEnvironmentError {
  query: Query!
}

type Mutation {
  accessTokenCreate(input: AccessTokenCreateInput!): AccessTokenCreatePayload!
  accessTokenDelete(input: AccessTokenDeleteInput!): AccessTokenDeletePayload!
  accountIntegrationCreate(accountId: ID!, input: AccountIntegrationInput!): AccountIntegrationMutationPayload!
  accountIntegrationDelete(id: ID!): AccountIntegrationMutationPayload!
  accountIntegrationUpdate(id: ID!, input: AccountIntegrationInput!): AccountIntegrationMutationPayload!
  branchCreate(input: BranchCreateInput!): BranchCreatePayload!
  branchDelete(accountSlug: String!, graphSlug: String, branchName: String!, projectSlug: String): BranchDeletePayload!
  branchUpdate(input: BranchUpdateInput!): BranchUpdatePayload!
  customDomainCreate(input: CustomDomainCreateInput!): CustomDomainCreatePayload!
  customDomainDelete(input: CustomDomainDeleteInput!): CustomDomainDeletePayload!
  customDomainReplace(input: CustomDomainReplaceInput!): CustomDomainReplacePayload!
  deleteSubgraph(input: DeleteSubgraphInput!): DeleteSubgraphPayload!
  deploymentCreate(input: DeploymentCreateInput!): DeploymentCreatePayload!
  deploymentCreateBySlug(input: DeploymentBySlugCreateInput!): DeploymentCreatePayload!
  deploymentRedeploy(id: ID!): DeploymentRedeployPayload!
  endpointConfigUpdate(input: EndpointConfigUpdateInput!): EndpointConfigUpdatePayload!
  environentVariableUpsert(input: EnvironmentVariableCreateInput!): EnvironmentVariableCreatePayload!
  environentVariableUpsertBySlug(input: EnviromentVariableUpsertInput!): EnvironmentVariableCreatePayload!
  environmentVariableCreate(input: EnvironmentVariableCreateInput!): EnvironmentVariableCreatePayload!
  environmentVariableDelete(input: EnvironmentVariableDeleteInput!): EnvironmentVariableDeletePayload!
  environmentVariableDeleteWithValues(input: EnvironmentVariableDeleteByValuesInput!): EnvironmentVariableDeleteByValuesPayload!
  environmentVariableDeleteWithValuesBySlug(input: EnvironmentVariableDeleteByValuesSlugsInput!): EnvironmentVariableDeleteByValuesPayload!
  environmentVariableUpdate(input: EnvironmentVariableUpdateInput!): EnvironmentVariableUpdatePayload!
  githubUserTokenUpdate(input: GithubUserTokenUpdateInput!): GithubUserTokenUpdatePayload!
  githubUserTokenUpdateE2E(input: GithubUserTokenUpdateE2EInput!): GithubUserTokenUpdateE2EPayload!
  graphAddOwner(graphId: ID!, ownerId: ID!): GraphAddOwnerPayload!
  graphApiKeyCreate(input: GraphApiKeyCreateInput!): GraphApiKeyCreatePayload!
  graphApiKeyDelete(input: GraphApiKeyDeleteInput!): GraphApiKeyDeletePayload!
  graphApiKeyUpdate(input: GraphApiKeyUpdateInput!): GraphApiKeyUpdatePayload!
  graphCreate(input: GraphCreateInput!): GraphCreatePayload!
  graphCreateFromRepository(input: GraphCreateFromRepositoryInput!): GraphCreateFromRepositoryPayload!
  graphCreateFromSchema(input: GraphCreateFromSchemaInput!): GraphCreateFromSchemaPayload!
  graphCreateFromTemplate(input: GraphCreateFromTemplateInput!): GraphCreateFromTemplatePayload!
  graphDelete(input: GraphDeleteInput!): GraphDeletePayload!
  graphIntegrationCreate(graphId: ID!, accountIntegrationId: ID!, input: GraphIntegrationInput!): GraphIntegrationMutationPayload!
  graphIntegrationDelete(id: ID!): GraphIntegrationMutationPayload!
  graphIntegrationUpdate(id: ID!, input: GraphIntegrationInput!): GraphIntegrationMutationPayload!
  graphOperationCheckConfigurationUpdate(input: GraphOperationCheckConfigurationInput!): GraphOperationCheckConfigurationUpdatePayload!
  graphRemoveOwner(graphId: ID!, ownerId: ID!): GraphRemoveOwnerPayload!
  graphUpdate(input: GraphUpdateInput!): GraphUpdatePayload!
  inviteAccept(input: InviteAcceptInput!): InviteAcceptPayload!
  inviteCancel(input: InviteCancelInput!): InviteCancelPayload!
  inviteDecline(input: InviteDeclineInput!): InviteDeclinePayload!
  inviteSend(input: InviteSendInput!): InviteSendPayload!
  memberDelete(input: MemberDeleteInput!): MemberDeletePayload!
  memberUpdate(input: MemberUpdateInput!): MemberUpdatePayload!
  organizationCreate(input: OrganizationCreateInput!): OrganizationCreatePayload!
  organizationDelete(input: OrganizationDeleteInput!): OrganizationDeletePayload!
  organizationPaymentMethodReplace(accountId: ID!, stripePaymentMethodId: String!): OrganizationPaymentMethodReplacePayload!
  organizationSetupPaymentMethod(accountId: ID!, stripePaymentMethodId: String!): OrganizationSetupPaymentMethod!
  organizationSlugUpdate(input: OrganizationSlugUpdateInput!): OrganizationSlugUpdatePayload!
  organizationUpdate(input: OrganizationUpdateInput!): OrganizationUpdatePayload!
  personalAccountDelete: PersonalAccountDeletePayload!
  personalAccountSlugUpdate(input: PersonalAccountSlugUpdateInput!): PersonalAccountSlugUpdatePayload!
  personalAccountUpdate(input: PersonalAccountUpdateInput!): PersonalAccountUpdatePayload!
  publish(input: PublishInput!): PublishPayload!
  schemaCheckCreate(input: SchemaCheckCreateInput!): SchemaCheckPayload!
  schemaProposalApprove(input: SchemaProposalApproveInput!): SchemaProposalApprovePayload!
  schemaProposalCommentReply(parentCommentId: ID!, text: String!): SchemaProposalCommentReplyPayload!
  schemaProposalCommentThreadCreate(input: SchemaProposalCommentThreadCreateInput!): SchemaProposalCommentThreadCreatePayload!
  schemaProposalCommentThreadResolve(rootCommentId: ID!): SchemaProposalCommentThreadResolvePayload!
  schemaProposalCreate(input: SchemaProposalCreateInput!): SchemaProposalCreatePayload!
  schemaProposalDelete(id: ID!): SchemaProposalDeletePayload!
  schemaProposalEdit(input: SchemaProposalEditInput!): SchemaProposalEditPayload!
  schemaProposalReject(input: SchemaProposalRejectInput!): SchemaProposalRejectPayload!
  schemaProposalRequestReview(input: SchemaProposalRequestReviewInput!): SchemaProposalRequestReviewPayload!
  slackIntegrationCreate(input: SlackIntegrationCreateInput!): SlackNotificationCreatePayload!
  slackNotificationDelete(id: String!): SlackNotificationDeletePayload!
  stripeSetupIntentCreate: StripeSetupIntentCreatePayload!
  subgraphAddOwner(owner: ID!, branchId: ID!, subgraphName: String!): SubgraphAddOwnerPayload!
  subgraphRemoveOwner(branchId: ID!, subgraphName: String!): SubgraphRemoveOwnerPayload!
  teamAddMember(teamId: ID!, memberId: ID!): TeamAddMemberPayload!
  teamAssignRole(role: TeamRole!, teamId: ID!, memberId: ID!): TeamAssignRolePayload!
  teamCreate(name: String!, organizationId: ID!): TeamCreatePayload!
  teamDelete(teamId: ID!): TeamDeletePayload!
  teamRemoveMember(teamId: ID!, memberId: ID!): TeamRemoveMemberPayload!
  trustedDocumentsSubmit(accountSlug: String, graphSlug: String, projectSlug: String, branchSlug: String!, clientName: String!, documents: [TrustedDocumentInput!]!): TrustedDocumentsSubmitPayload!
}

type NameAlreadyExistsError {
  query: Query!
}

type NameContainsInvalidCharactersError {
  query: Query!
}

type NameSizeCheckError {
  maxLength: Int!
  message: String!
  query: Query!
}

type NameTooLongError {
  query: Query!
}

interface Node {
  id: ID!
}

type NoEnvironmentsSetError {
  query: Query!
}

type NotAllowedError {
  query: Query!
}

type NotAllowedToCancelInvitesError {
  query: Query!
}

type NotAllowedToDeleteOrganizationError {
  query: Query!
}

type NotAllowedToSendInvitesError {
  query: Query!
}

type NotAllowedToSlugUpdateError {
  query: Query!
}

type NotAllowedToUpdateOrganizationError {
  query: Query!
}

type OldAccessTokenError {
  query: Query!
}

type Operation implements Node {
  id: ID!
  name: String
  normalizedQuery: String!
  type: OperationType!
}

type OperationCheckError {
  message: String!
  severity: SchemaCheckErrorSeverity!
  title: String!
}

scalar OperationNormalizedQueryHash

type OperationNotAllowedByPlanError {
  query: Query!
}

enum OperationType {
  QUERY
  MUTATION
  SUBSCRIPTION
}

type OrbBillingAddress {
  city: String
  country: String
  line1: String
  line2: String
  postalCode: String
  state: String
}

input OrbBillingAddressInput {
  city: String
  country: String
  line1: String
  line2: String
  postalCode: String
  state: String
}

type OrbCustomer {
  billingAddress: OrbBillingAddress
  email: String!
  id: String!
  name: String!
  subscriptions(cursor: String): OrbPaginatedSubscriptions!
  taxId: OrbTaxId
}

input OrbCustomerUpdateInput {
  name: String
  email: String
  taxId: OrbTaxIdInput
  billingAddress: OrbBillingAddressInput
}

type OrbInvoice {
  currency: String!
  dueDate: DateTime!
  id: String!
  invoiceDate: DateTime!
  invoiceNumber: String!
  invoicePdf: Url!
  lineItems: [OrbInvoiceLineItem!]!
  status: OrbInvoiceStatus!
  total: String!
}

type OrbInvoiceLineItem {
  amount: String!
  endDate: DateTime!
  id: String!
  name: String!
  price: OrbPrice!
  quantity: Float!
  startDate: DateTime!
}

enum OrbInvoiceStatus {
  ISSUED
  PAID
  SYNCED
  VOID
  DRAFT
}

type OrbPaginatedInvoices {
  data: [OrbInvoice!]!
  paginationMetadata: OrbPaginationMetadata!
}

type OrbPaginatedSubscriptions {
  data: [OrbSubscription!]!
  paginationMetadata: OrbPaginationMetadata!
}

type OrbPaginationMetadata {
  nextCursor: String
}

type OrbPlan {
  externalPlanId: String
}

type OrbPrice {
  currency: String!
  modelType: OrbPriceModelType!
  packageConfig: OrbPricePackageConfig
  unitConfig: OrbPriceUnitConfig
}

enum OrbPriceModelType {
  UNIT
  TIERED
  BULK
  PACKAGE
  BPS
  TIERED_BPS
  BULK_BPS
  MATRIX
}

type OrbPricePackageConfig {
  packageAmount: String!
  packageSize: Float!
}

type OrbPriceUnitConfig {
  unitAmount: String!
}

type OrbSubscription {
  currentBillingPeriodEndDate: DateTime
  currentBillingPeriodStartDate: DateTime
  endDate: DateTime
  id: String!
  invoices(cursor: String): OrbPaginatedInvoices!
  plan: OrbPlan!
  status: OrbSubscriptionStatus!
  upcomingInvoice: OrbUpcomingInvoice
}

enum OrbSubscriptionStatus {
  ACTIVE
  ENDED
  UPCOMING
}

type OrbTaxId {
  country: String!
  type: OrbTaxIdType!
  value: String!
}

input OrbTaxIdInput {
  value: String!
  type: OrbTaxIdType!
  country: String!
}

enum OrbTaxIdType {
  AE_TRN
  AU_ABN
  AU_ARN
  BG_UIC
  BR_CNPJ
  BR_CPF
  CA_BN
  CA_GST_HST
  CA_PST_BC
  CA_PST_MB
  CA_PST_SK
  CA_QST
  CH_VAT
  CL_TIN
  EG_TIN
  ES_CIF
  EU_OSS_VAT
  EU_VAT
  GB_VAT
  GE_VAT
  HK_BR
  HU_TIN
  ID_NPWP
  IL_VAT
  IN_GST
  IS_VAT
  JP_CN
  JP_RN
  JP_TRN
  KE_PIN
  KR_BRN
  LI_UID
  MX_RFC
  MY_FRP
  MY_ITN
  MY_SST
  NO_VAT
  NZ_GST
  PH_TIN
  RU_INN
  RU_KPP
  SA_VAT
  SG_GST
  SG_UEN
  SI_TIN
  TH_VAT
  TR_TIN
  TW_VAT
  UA_VAT
  US_EIN
  ZA_VAT
}

type OrbUpcomingInvoice {
  currency: String!
  lineItems: [OrbUpcomingInvoiceLineItem!]!
  subtotal: String!
  targetDate: DateTime!
}

type OrbUpcomingInvoiceLineItem {
  amount: String!
  endDate: DateTime!
  name: String!
  price: OrbPrice!
  quantity: Float!
  startDate: DateTime!
}

type OrbValidationError {
  errors: [String!]!
  query: Query!
}

type Organization implements Account & Node {
  accessTokens(after: String, before: String, first: Int, last: Int): AccessTokenConnection!
  addToSlackLink: String!
  createdAt: DateTime!
  graphs(after: String, before: String, first: Int, last: Int): GraphConnection!
  graphsCountStatus: ResourceStatus!
  id: ID!
  integrations: [AccountIntegration!]! @deprecated(reason: "to be removed soon")
  invites(after: String, before: String, first: Int, last: Int): InviteConnection!
  members(after: String, before: String, first: Int, last: Int): MemberConnection!
  name: String!
  orbActiveSubscription: OrbSubscription
  orbCustomer: OrbCustomer
  plan: GrafbasePlan!
  resources: AccountResources! @deprecated(reason: "Not relevant for organizations")
  resourcesUsageDashboard(filter: AccountResourcesUsageDashboardFilter): AccountResourcesUsageDashboardPayload!
  samlDomain: String
  slackIntegration: SlackIntegration
  slug: String!
  status: AccountStatus!
  stripeCustomer: StripeCustomer
  teams(after: String, first: Int): TeamConnection!
  trialExpiresAt: DateTime
}

type OrganizationConnection {
  edges: [OrganizationEdge!]!
  nodes: [Organization!]!
  pageInfo: PageInfo!
}

input OrganizationCreateInput {
  name: String!
  slug: String!
  email: String
  stripePaymentMethodId: String
}

union OrganizationCreatePayload = NameSizeCheckError | OrganizationCreateSuccess | ReservedSlugsCheckError | SlugAlreadyExistsError | SlugError | SlugSizeCheckError | TrialPlanUnavailableError

type OrganizationCreateSuccess {
  member: Member!
  organization: Organization!
  query: Query!
}

input OrganizationDeleteInput {
  id: ID!
}

union OrganizationDeletePayload = NotAllowedToDeleteOrganizationError | OrganizationDeleteSuccess | OrganizationDoesNotExistError

type OrganizationDeleteSuccess {
  deletedId: ID!
  query: Query!
}

type OrganizationDoesNotExistError {
  query: Query!
}

type OrganizationEdge {
  cursor: String!
  node: Organization!
}

type OrganizationOwnershipNotTransferredError {
  query: Query!
}

union OrganizationPaymentMethodReplacePayload = MissingStripeCustomerError | NotAllowedError | OrganizationDoesNotExistError | OrganizationSuccessfulUpdate

union OrganizationSetupPaymentMethod = HasAlreadyPaymentMethodError | NotAllowedError | OrganizationDoesNotExistError | OrganizationUpgradeToProSuccess

input OrganizationSlugUpdateInput {
  id: ID!
  slug: String!
}

union OrganizationSlugUpdatePayload = NotAllowedToSlugUpdateError | OrganizationDoesNotExistError | OrganizationSlugUpdateSuccess | ReservedSlugsCheckError | SlugAlreadyExistsError | SlugError | SlugSizeCheckError

type OrganizationSlugUpdateSuccess {
  organization: Organization!
  query: Query!
}

type OrganizationSuccessfulUpdate {
  organization: Organization!
  query: Query!
}

input OrganizationUpdateInput {
  id: ID!
  name: String
  orbCustomer: OrbCustomerUpdateInput
}

union OrganizationUpdatePayload = NameSizeCheckError | NotAllowedToUpdateOrganizationError | OrbValidationError | OrganizationDoesNotExistError | OrganizationUpdateSuccess

type OrganizationUpdateSuccess {
  organization: Organization!
  query: Query!
}

type OrganizationUpgradeToProSuccess {
  organization: Organization!
  query: Query!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type PersonalAccount implements Account {
  accessTokens(after: String, before: String, first: Int, last: Int): AccessTokenConnection!
  createdAt: DateTime!
  graphs(after: String, before: String, first: Int, last: Int): GraphConnection!
  graphsCountStatus: ResourceStatus!
  id: ID!
  name: String!
  plan: GrafbasePlan!
  resources: AccountResources! @deprecated(reason: "use graphs_count_status")
  resourcesUsageDashboard(filter: AccountResourcesUsageDashboardFilter): AccountResourcesUsageDashboardPayload!
  slug: String!
  status: AccountStatus!
}

union PersonalAccountDeletePayload = OrganizationOwnershipNotTransferredError | PersonalAccountDeleteSuccess

type PersonalAccountDeleteSuccess {
  deletedId: ID!
  query: Query!
}

input PersonalAccountSlugUpdateInput {
  slug: String!
}

union PersonalAccountSlugUpdatePayload = PersonalAccountSlugUpdateSuccess | ReservedSlugsCheckError | SlugAlreadyExistsError | SlugError | SlugSizeCheckError

type PersonalAccountSlugUpdateSuccess {
  query: Query!
}

input PersonalAccountUpdateInput {
  name: String!
}

union PersonalAccountUpdatePayload = NameSizeCheckError | PersonalAccountUpdateSuccess

type PersonalAccountUpdateSuccess {
  query: Query!
}

type PreviousRequestAnalytcs {
  metrics: RequestMetrics!
  timeSeries: RequestMetricsTimeSeries!
}

type ProjectBranchDoesNotExistError {
  query: Query!
}

type ProjectDoesNotExistError {
  query: Query!
}

type ProjectDopplerIntegration {
  automatedRedeploy: Boolean!
  configName: String!
  projectName: String!
}

type ProjectNotFederatedError {
  query: Query!
}

type ProjectNotManagedError {
  query: Query!
}

type ProjectNotStandaloneError {
  query: Query!
}

type ProjectScopeLimitExceededError {
  query: Query!
}

type PublishForbidden {
  query: Query!
}

input PublishInput {
  message: String
  schema: String!
  accountSlug: String!
  graphSlug: String
  projectSlug: String
  branch: String
  subgraph: String!
  url: String!
}

union PublishPayload = FederatedGraphCompositionError | ProjectDoesNotExistError | ProjectNotFederatedError | PublishForbidden | PublishSuccess | SchemaRegistryBranchDoesNotExistError

type PublishSuccess {
  query: Query!
}

type Query {
  accessTokens(after: String, before: String, first: Int, last: Int): AccessTokenConnection!
  accountBySlug(slug: String!): Account
  accountCreationValidate(input: AccountCreationValidateInput!): AccountCreationValidatePayload!
  branch(name: String, accountSlug: String, graphSlug: String, projectSlug: String): Branch
  branchByDomain(domain: String!): Branch
  customDomainByName(name: String!, projectId: ID, graphId: ID): CustomDomain
  deployment(id: ID!): Deployment
  dopplerConfigs(accountIntegrationId: ID!, dopplerProjectName: String!): [DopplerConfig!]!
  dopplerProjects(accountIntegrationId: ID!): [DopplerProject!]!
  gitAccounts(provider: GitProvider!): GitAccountsPayload!
  gitRepoByUrl(url: Url!): GitRepository!
  gitRepos(query: String, provider: GitProvider!, gitAccountId: String!): [GitRepository!]!
  graphByAccountSlug(accountSlug: String!, graphSlug: String!): Graph
  integrations: [Integration!]!
  invite(id: ID!): Invite
  node(id: ID!): Node
  schema(branch: String!, url: Url!): String
  schemaCheck(id: ID!): SchemaCheck
  schemaProposal(id: ID!): SchemaProposal
  schemaVersion(id: ID!): SchemaVersion
  schemaVersions(after: String, before: String, first: Int, last: Int, accountSlug: String!, graphSlug: String, projectSlug: String, branch: String, subgraphName: String, populated: Boolean! = true): SchemaVersionConnection!
  subgraph(accountSlug: String!, graphSlug: String, projectSlug: String, branch: String, subgraphName: String!): Subgraph
  team(id: ID!): Team
  teamBySlug(slug: String!, organizationSlug: String!): Team
  viewer: User
}

type RepositoryContainsNoBranchesError {
  query: Query!
}

type RepositorySlugInUseError {
  query: Query!
}

type Request implements Node {
  clientName: String!
  clientVersion: String!
  endedAt: DateTime!
  errorCount: Int!
  errorCountByCode: [ErrorCountByCode!]!
  httpRequestMethod: String!
  httpStatusCode: Int!
  id: ID!
  operations: [RequestOperation!]!
  rootSpanId: ID!
  startedAt: DateTime!
  trace: Trace!
  urlPath: String!
  userAgent: String!
}

type RequestAnalytics {
  metrics: RequestMetrics!
  periodEnd: DateTime!
  periodStart: DateTime!
  previousPeriodAnalytics: PreviousRequestAnalytcs
  timeSeries: RequestMetricsTimeSeries!
}

type RequestConnection {
  edges: [RequestEdge!]!
  nodes: [Request!]!
  pageInfo: PageInfo!
}

type RequestEdge {
  cursor: String!
  node: Request!
}

input RequestFilters {
  """
  
      Defaults to production branch
      
  """
  branchName: String
  duration: DurationFilter
  traceId: [String!]

  """
  
      Use this if you really care about having a specific duration like 1 hour, 7 days, etc.
      
  """
  range: Duration

  """
  
      Use this if you *at least* the data between `from` and `to` to be provided. You may get
      more, but never less.
      
  """
  from: DateTime

  """
  
      To be used in conjunction with with either `range` or `from`.
      
  """
  to: DateTime!
  operationName: [String!]
  clientName: [String!]

  """
  
      Only used if client name is specified.
      
  """
  clientVersion: [String!]
  httpStatusCode: [Int!]
  operationType: [OperationType!]
  errorCode: [String!]
}

type RequestLogEvent implements LogEvent {
  branch: String!
  createdAt: DateTime!
  deploymentId: ID!
  duration: Int!
  environment: BranchEnvironment!
  httpMethod: String!
  httpStatus: Int!
  id: String!
  logLevel: LogLevel!
  message: String!
  region: String!
  url: String!
}

type RequestMetrics {
  cacheHitCount: Int!
  cacheMissCount: Int!
  cachePassCount: Int!
  cacheableRequestCount: Int!
  error4XxCount: Int!
  error5XxCount: Int!
  errorGraphqlCount: Int!
  latencyMsP95: Int
  latencyMsP99: Int
  requestCount: Int!
}

type RequestMetricsTimeSeries {
  aggregationStep: Duration!
  data: [RequestMetricsTimeSeriesDataPoint!]!
}

type RequestMetricsTimeSeriesDataPoint {
  cacheHitCount: Int!
  cacheMissCount: Int!
  cachePassCount: Int!
  cacheableRequestCount: Int!
  dateTime: DateTime!
  error4XxCount: Int!
  error5XxCount: Int!
  errorGraphqlCount: Int!
  latencyMsP95: Int
  latencyMsP99: Int
  requestCount: Int!
}

type RequestMetricsTimeSeriesDataPointV2 {
  cacheHitCount: Int!
  cacheMissCount: Int!
  cachePassCount: Int!
  count: Int!
  dateTime: DateTime!
  error4XxCount: Int!
  error5XxCount: Int!
  errorGraphqlCount: Int!
  latencyMsPercentiles: [Int!]!
}

type RequestMetricsTimeSeriesV2 {
  overall: RequestMetricsV2!
  points: [RequestMetricsTimeSeriesDataPointV2!]!
  previousPeriod: RequestMetricsTimeSeriesV2
}

type RequestMetricsV2 {
  cacheHitCount: Int!
  cacheMissCount: Int!
  cachePassCount: Int!
  count: Int!
  error4XxCount: Int!
  error5XxCount: Int!
  errorGraphqlCount: Int!
  latencyMsPercentiles: [Int!]!
}

type RequestOperation {
  name: String!
  type: OperationType!
}

type ReservedPrefixError {
  query: Query!
}

type ReservedSlugsCheckError {
  message: String!
  query: Query!
}

type ResourceStatus {
  limit: Int
  percentage: Float
  remaining: Int
  unit: UnitType!
  used: Int!
}

type ReusedId {
  documentId: String!
  existingDocumentText: String!
  newDocumentText: String!
}

type ReusedIds {
  reused: [ReusedId!]!
}

enum SchemaChangeType {
  SCHEMA_DEFINITION_ADDED
  SCHEMA_DEFINITION_REMOVED
  SCHEMA_EXTENSION_ADDED
  SCHEMA_EXTENSION_REMOVED
  FIELD_ARGUMENT_DEFAULT_ADDED
  FIELD_ARGUMENT_DEFAULT_REMOVED
  FIELD_ARGUMENT_DESCRIPTION_CHANGED
  FIELD_ARGUMENT_DEFAULT_CHANGED
  FIELD_ARGUMENT_TYPE_CHANGED
  DIRECTIVE_REMOVED
  DIRECTIVE_ADDED
  DIRECTIVE_DESCRIPTION_CHANGED
  DIRECTIVE_LOCATION_ADDED
  DIRECTIVE_LOCATION_REMOVED
  DIRECTIVE_ARGUMENT_ADDED
  DIRECTIVE_ARGUMENT_REMOVED
  DIRECTIVE_ARGUMENT_DESCRIPTION_CHANGED
  DIRECTIVE_ARGUMENT_DEFAULT_VALUE_CHANGED
  DIRECTIVE_ARGUMENT_TYPE_CHANGED
  ENUM_ADDED
  ENUM_REMOVED
  ENUM_VALUE_REMOVED
  ENUM_VALUE_ADDED
  ENUM_VALUE_DESCRIPTION_CHANGED
  ENUM_VALUE_DEPRECATION_REASON_CHANGED
  ENUM_VALUE_DEPRECATION_REASON_ADDED
  ENUM_VALUE_DEPRECATION_REASON_REMOVED
  FIELD_REMOVED
  FIELD_ADDED
  FIELD_DESCRIPTION_CHANGED
  FIELD_DESCRIPTION_ADDED
  FIELD_DESCRIPTION_REMOVED
  FIELD_DEPRECATION_ADDED
  FIELD_DEPRECATION_REMOVED
  FIELD_DEPRECATION_REASON_CHANGED
  FIELD_DEPRECATION_REASON_ADDED
  FIELD_DEPRECATION_REASON_REMOVED
  FIELD_TYPE_CHANGED
  FIELD_ARGUMENT_ADDED
  FIELD_ARGUMENT_REMOVED
  INPUT_OBJECT_REMOVED
  INPUT_OBJECT_ADDED
  INPUT_FIELD_REMOVED
  INPUT_FIELD_ADDED
  INPUT_FIELD_DESCRIPTION_ADDED
  INPUT_FIELD_DESCRIPTION_REMOVED
  INPUT_FIELD_DESCRIPTION_CHANGED
  INPUT_FIELD_DEFAULT_VALUE_CHANGED
  INPUT_FIELD_TYPE_CHANGED
  OBJECT_TYPE_INTERFACE_ADDED
  OBJECT_TYPE_INTERFACE_REMOVED
  SCHEMA_QUERY_TYPE_CHANGED
  SCHEMA_MUTATION_TYPE_CHANGED
  SCHEMA_SUBSCRIPTION_TYPE_CHANGED
  TYPE_REMOVED
  TYPE_ADDED
  TYPE_KIND_CHANGED
  TYPE_DESCRIPTION_CHANGED
  TYPE_DESCRIPTION_REMOVED
  TYPE_DESCRIPTION_ADDED
  UNION_ADDED
  UNION_REMOVED
  UNION_MEMBER_REMOVED
  UNION_MEMBER_ADDED
  INTERFACE_ADDED
  INTERFACE_REMOVED
  INTERFACE_IMPLEMENTATION_ADDED
  INTERFACE_IMPLEMENTATION_REMOVED
  SCALAR_ADDED
  SCALAR_REMOVED
}

type SchemaCheck {
  compositionCheckErrors: [CompositionCheckError!]!
  createdAt: DateTime!
  errorCount: Int!
  gitCommit: SchemaCheckGitCommit
  id: ID!
  lintCheckErrors: [LintCheckError!]!
  operationCheckErrors: [OperationCheckError!]!
  publishedSchemaVersion: ID @deprecated(reason: "This was never populated with relevant data")
  schema: String!
  subgraphName: String
  validationCheckErrors: [ValidationCheckError!]!
}

type SchemaCheckConnection {
  edges: [SchemaCheckEdge!]!
  nodes: [SchemaCheck!]!
  pageInfo: PageInfo!
}

input SchemaCheckCreateInput {
  schema: String!
  accountSlug: String!
  graphSlug: String
  projectSlug: String
  branch: String
  subgraphName: String
  gitCommit: SchemaCheckGitCommitInput
}

type SchemaCheckEdge {
  cursor: String!
  node: SchemaCheck!
}

enum SchemaCheckErrorSeverity {
  ERROR
  WARNING
}

type SchemaCheckGitCommit {
  authorAvatarUrl: String
  authorName: String!
  branch: String!
  commitSha: String!
  commitUrl: String
  message: String!
}

input SchemaCheckGitCommitInput {
  message: String!
  branch: String!
  authorAvatarUrl: String
  commitSha: String!
  commitUrl: String
  authorName: String!
}

union SchemaCheckPayload = GraphBranchDoesNotExistError | GraphDoesNotExistError | ProjectBranchDoesNotExistError | ProjectDoesNotExistError | SchemaCheck | SubgraphNameMissingOnFederatedGraphError | SubgraphNameMissingOnFederatedProjectError | SubgraphNameProvidedOnSingleProjectError | SubgraphNameProvidedOnStandaloneGraphError | SubgraphNameProvidedOnStandaloneProjectError

type SchemaProposal {
  author: User
  comments: [SchemaProposalComment!]!
  createdAt: DateTime!
  description: String
  id: ID!
  status: SchemaProposalStatus!
  subgraph(subgraphName: String!): SchemaProposalSubgraph
  subgraphs: [SchemaProposalSubgraph!]!
  title: String!
}

input SchemaProposalApproveInput {
  id: ID!
  message: String
}

union SchemaProposalApprovePayload = SchemaProposalApproveSuccess

type SchemaProposalApproveSuccess {
  query: Query!
}

interface SchemaProposalComment {
  author: User
  createdAt: DateTime!
  id: ID!
  text: String!
}

type SchemaProposalCommentOnLine implements SchemaProposalComment {
  author: User
  context(contextLines: Int!): String
  createdAt: DateTime!
  id: ID!
  line: Int
  path: String!
  replies: [SchemaProposalReply!]!
  resolved: Boolean!
  subgraphName: String!
  text: String!
}

type SchemaProposalCommentOnProposal implements SchemaProposalComment {
  author: User
  createdAt: DateTime!
  id: ID!
  replies: [SchemaProposalReply!]!
  text: String!
}

type SchemaProposalCommentOnSdl implements SchemaProposalComment {
  author: User
  createdAt: DateTime!
  id: ID!
  replies: [SchemaProposalReply!]!
  resolved: Boolean!
  text: String!
}

union SchemaProposalCommentReplyPayload = SchemaProposalCommentReplySuccess

type SchemaProposalCommentReplySuccess {
  query: Query!
}

input SchemaProposalCommentThreadCreateInput {
  """
  
      The content of the comment.
      
  """
  text: String!

  """
  
      Must be provided if and only if location is Line.
      
  """
  subgraphName: String

  """
  
      Must be provided if and only if location is Line.
      
  """
  line: Int

  """
  
      The parent schema proposal.
      
  """
  schemaProposalId: ID!

  """
  
      Where the comment is located.
      
  """
  location: SchemaProposalCommentThreadLocation!

  """
  
      The whole subgraph schema being commented on. Must be provided if and only if location is Line.
      
      This argument is necessary to avoid cases where the schema has been updated
  between the time it was retried and the time the comment is posted. In these
  cases, if we use the latest subgraph schema, the line numbers may have changed
  and the comment would end up in the wrong place.
      
  """
  subgraphSchema: String
}

union SchemaProposalCommentThreadCreatePayload = SchemaProposalCommentThreadCreateSuccess

type SchemaProposalCommentThreadCreateSuccess {
  query: Query!
}

enum SchemaProposalCommentThreadLocation {
  LINE
  SDL
  PROPOSAL
}

union SchemaProposalCommentThreadResolvePayload = SchemaProposalCommentThreadResolveSuccess

type SchemaProposalCommentThreadResolveSuccess {
  affectedRows: Int!
  query: Query!
}

type SchemaProposalConnection {
  edges: [SchemaProposalEdge!]!
  nodes: [SchemaProposal!]!
  pageInfo: PageInfo!
}

input SchemaProposalCreateInput {
  title: String!
  branchId: ID!
  description: String
}

union SchemaProposalCreatePayload = SchemaProposalCreateSuccess

type SchemaProposalCreateSuccess {
  query: Query!
  schemaProposal: SchemaProposal!
}

union SchemaProposalDeletePayload = SchemaProposalDeleteSuccess | SchemaProposalDoesNotExistError

type SchemaProposalDeleteSuccess {
  query: Query!
}

type SchemaProposalDoesNotExistError {
  query: Query!
}

type SchemaProposalEdge {
  cursor: String!
  node: SchemaProposal!
}

input SchemaProposalEditInput {
  subgraphs: [SchemaProposalEditSubgraph!]!
  description: String
  schemaProposalId: ID!
}

type SchemaProposalEditParserError {
  error: String!
  spanEnd: Int!
  spanStart: Int!
  subgraphName: String!
}

type SchemaProposalEditParserErrors {
  errors: [SchemaProposalEditParserError!]!
}

union SchemaProposalEditPayload = SchemaProposalDoesNotExistError | SchemaProposalEditParserErrors | SchemaProposalEditSuccess

input SchemaProposalEditSubgraph {
  name: String!
  schema: String
}

type SchemaProposalEditSuccess {
  query: Query!
}

input SchemaProposalFilter {
  status: SchemaProposalStatus
}

input SchemaProposalRejectInput {
  id: ID!
  message: String
}

union SchemaProposalRejectPayload = SchemaProposalRejectSuccess

type SchemaProposalRejectSuccess {
  query: Query!
}

type SchemaProposalReply implements SchemaProposalComment {
  author: User
  createdAt: DateTime!
  id: ID!
  text: String!
}

input SchemaProposalRequestReviewInput {
  id: ID!
}

union SchemaProposalRequestReviewPayload = SchemaProposalRequestReviewSuccess

type SchemaProposalRequestReviewSuccess {
  query: Query!
}

enum SchemaProposalStatus {
  DRAFT
  APPROVED
  IMPLEMENTED
  REJECTED
  IN_REVIEW
}

type SchemaProposalSubgraph {
  comments: [SchemaProposalComment!]!
  diffSnippets: [DiffSnippet!]!
  name: String!
  sdl: String
  status: SchemaProposalSubgraphStatus!
}

enum SchemaProposalSubgraphStatus {
  CREATED
  EDITED
  DELETED
  UNCHANGED
}

type SchemaRegistryBranchDoesNotExistError {
  query: Query!
}

type SchemaVersion {
  changes(after: String, before: String, first: Int, last: Int): SchemaVersionChangeConnection!
  createdAt: DateTime!
  delta: SchemaVersionDelta!
  id: ID!
  message: String
  schema: String!
}

type SchemaVersionChange {
  message: String!
  path: String
  type: SchemaChangeType!
}

type SchemaVersionChangeConnection {
  edges: [SchemaVersionChangeEdge!]!
  nodes: [SchemaVersionChange!]!
  pageInfo: PageInfo!
}

type SchemaVersionChangeEdge {
  cursor: String!
  node: SchemaVersionChange!
}

type SchemaVersionConnection {
  edges: [SchemaVersionEdge!]!
  nodes: [SchemaVersion!]!
  pageInfo: PageInfo!
}

type SchemaVersionDelta {
  added: Int!
  modified: Int!
  removed: Int!
}

type SchemaVersionEdge {
  cursor: String!
  node: SchemaVersion!
}

type SlackChannel {
  id: String!
  name: String!
}

type SlackIntegration {
  availableChannels: [SlackChannel!]!
  notifications: [SlackNotification!]!
}

input SlackIntegrationCreateInput {
  """
  
      The graph_id field is deprecated. Pass branch_id instead.
      
  """
  graphId: String
  branchId: ID
  tokenId: String!
  channelId: String!
  channelName: String!
}

type SlackNotification {
  branchId: String!
  channelName: String!
  graphId: String! @deprecated(reason: "Graphs are being removed. Please use SlackNotification.branch_id instead")
  id: String!
}

union SlackNotificationCreatePayload = ProjectDoesNotExistError | SlackNotification

union SlackNotificationDeletePayload = Query

type SlugAlreadyExistsError {
  query: Query!
}

type SlugError {
  actual: String!
  expected: String!
  message: String!
  query: Query!
}

type SlugInvalidError {
  query: Query!
}

type SlugSizeCheckError {
  maxLength: Int!
  message: String!
  query: Query!
}

type SlugTooLongError {
  maxLength: Int!
  query: Query!
}

type StandaloneGraphsNoLongerSupportedError {
  query: Query!
}

type StripeCard {
  brand: String!
  expMonth: Int!
  expYear: Int!
  funding: String!
  last4: String!
}

type StripeCustomer {
  id: String!
  paymentMethods(limit: Int, type: StripePaymentMethodType, endingBefore: String, startingAfter: String): StripePaginatedPaymentMethods!
}

type StripePaginatedPaymentMethods {
  data: [StripePaymentMethod!]!
  hasMore: Boolean!
  nextPage: String
}

type StripePaymentMethod {
  card: StripeCard
  created: DateTime!
  id: String!
  type: StripePaymentMethodType!
}

enum StripePaymentMethodType {
  ACSS_DEBIT
  AFFIRM
  AFTERPAY_CLEARPAY
  ALIPAY
  AU_BECS_DEBIT
  BACS_DEBIT
  BANCONTACT
  BLIK
  BOLETO
  CARD
  CASHAPP
  CUSTOMER_BALANCE
  EPS
  FPX
  GIROPAY
  GRABPAY
  IDEAL
  KLARNA
  KONBINI
  LINK
  OXXO
  P24
  PAYNOW
  PIX
  PROMPTPAY
  SEPA_DEBIT
  SOFORT
  US_BANK_ACCOUNT
  WECHAT_PAY
}

type StripeSetupIntent {
  clientSecret: String!
  id: String!
}

union StripeSetupIntentCreatePayload = StripeSetupIntentCreateSuccess

type StripeSetupIntentCreateSuccess {
  query: Query!
  setupIntent: StripeSetupIntent!
}

type Subgraph {
  createdAt: DateTime!
  name: String!
  owners: [Team!]!
  schema: String!
  updatedAt: DateTime!
  url: String!
}

union SubgraphAddOwnerPayload = SubgraphAddOwnerSuccess

type SubgraphAddOwnerSuccess {
  query: Query!
}

type SubgraphNameMissingOnFederatedGraphError {
  query: Query!
}

type SubgraphNameMissingOnFederatedProjectError {
  query: Query!
}

type SubgraphNameProvidedOnSingleProjectError {
  query: Query! @deprecated(reason: "Type renamed to SubgraphNameProvidedOnStandaloneProjectError")
}

type SubgraphNameProvidedOnStandaloneGraphError {
  query: Query!
}

type SubgraphNameProvidedOnStandaloneProjectError {
  query: Query!
}

type SubgraphNotFoundError {
  query: Query!
}

union SubgraphRemoveOwnerPayload = SubgraphRemoveOwnerSuccess

type SubgraphRemoveOwnerSuccess {
  query: Query!
}

type Team implements Node {
  id: ID!
  members(after: String, first: Int): UserConnection!
  name: String!
  parent: Team
  parentTeamId: ID
  query: Query!
  slug: String!
  subteams(after: String, first: Int): TeamConnection!
}

union TeamAddMemberPayload = TeamAddMemberSuccess | TeamDoesNotExistError

type TeamAddMemberSuccess {
  query: Query!
}

union TeamAssignRolePayload = TeamAssignRoleSuccess | TeamDoesNotExistError

type TeamAssignRoleSuccess {
  query: Query!
}

type TeamConnection {
  edges: [TeamEdge!]!
  nodes: [Team!]!
  pageInfo: PageInfo!
}

union TeamCreatePayload = OrganizationDoesNotExistError | Team | TeamNameAlreadyTakenError

union TeamDeletePayload = TeamDeleteSuccess | TeamDoesNotExistError

type TeamDeleteSuccess {
  query: Query!
}

type TeamDoesNotExistError {
  query: Query!
}

type TeamEdge {
  cursor: String!
  node: Team!
}

type TeamNameAlreadyTakenError {
  query: Query!
}

union TeamRemoveMemberPayload = TeamDoesNotExistError | TeamRemoveMemberSuccess

type TeamRemoveMemberSuccess {
  query: Query!
}

enum TeamRole {
  MEMBER
  ADMIN
}

type TemplateDoesNotExistError {
  query: Query!
}

enum TimeAggregationGranularity {
  DAILY
  WEEKLY
  MONTHLY
}

type TimeSeries {
  data: [TimeSeriesDataPoint!]!
  statistics: TimeSeriesStatistics!
  unit: UnitType!
}

type TimeSeriesDataPoint {
  datetime: DateTime!
  value: Int!
}

type TimeSeriesStatistics {
  sum: Int!
}

type TokenDoesNotExistError {
  query: Query!
}

type TokenLimitExceededError {
  query: Query!
}

type TooManyCustomDomainsError {
  query: Query!
}

type TopClientByNameAndVersionOrderedByHighestCount {
  count: Int!
  name: String!
  version: String!
}

type TopClientByNameAndVersionOrderedByHighestErrorRatio {
  count: Int!
  errorCount: Int!
  name: String!
  version: String!
}

type TopClientByNameAndVersionOrderedByHighestLatency {
  latencyMs: Int!
  name: String!
  version: String!
}

type TopClientByNameOrderedByHighestCount {
  count: Int!
  name: String!
}

type TopClientByNameOrderedByHighestErrorRatio {
  count: Int!
  errorCount: Int!
  name: String!
}

type TopClientByNameOrderedByHighestLatency {
  latencyMs: Int!
  name: String!
}

type TopClients {
  byName: TopClientsByName!
  byNameAndVersion: TopClientsByNameAndVersion!
}

type TopClientsByName {
  orderedByHighestCount: [TopClientByNameOrderedByHighestCount!]!
  orderedByHighestErrorRatio: [TopClientByNameOrderedByHighestErrorRatio!]!
  orderedByHighestLatency: [TopClientByNameOrderedByHighestLatency!]!
}

type TopClientsByNameAndVersion {
  orderedByHighestCount: [TopClientByNameAndVersionOrderedByHighestCount!]!
  orderedByHighestErrorRatio: [TopClientByNameAndVersionOrderedByHighestErrorRatio!]!
  orderedByHighestLatency: [TopClientByNameAndVersionOrderedByHighestLatency!]!
}

type TopClientsForField {
  byName: TopClientsForFieldByName!
  byNameAndVersion: TopClientsForFieldByNameAndVersion!
}

type TopClientsForFieldByName {
  orderedByHighestCount: [TopClientByNameOrderedByHighestCount!]!
}

type TopClientsForFieldByNameAndVersion {
  orderedByHighestCount: [TopClientByNameAndVersionOrderedByHighestCount!]!
}

type TopOperationByNameAndHashOrderedByHighestCount {
  count: Int!
  name: String!
  normalizedQueryHash: OperationNormalizedQueryHash!
}

type TopOperationByNameAndHashOrderedByHighestErrorRatio {
  count: Int!
  errorCount: Int!
  name: String!
  normalizedQueryHash: OperationNormalizedQueryHash!
}

type TopOperationByNameAndHashOrderedByHighestLatency {
  latencyMs: Int!
  name: String!
  normalizedQueryHash: OperationNormalizedQueryHash!
}

type TopOperationByNameOrderedByHighestCount {
  count: Int!
  name: String!
}

type TopOperationByNameOrderedByHighestErrorRatio {
  count: Int!
  errorCount: Int!
  name: String!
}

type TopOperationByNameOrderedByHighestLatency {
  latencyMs: Int!
  name: String!
}

type TopOperations {
  byName: TopOperationsByName!
  byNameAndHash: TopOperationsByNameAndHash!
}

type TopOperationsByName {
  orderedByHighestCount: [TopOperationByNameOrderedByHighestCount!]!
  orderedByHighestErrorRatio: [TopOperationByNameOrderedByHighestErrorRatio!]!
  orderedByHighestLatency: [TopOperationByNameOrderedByHighestLatency!]!
}

type TopOperationsByNameAndHash {
  orderedByHighestCount: [TopOperationByNameAndHashOrderedByHighestCount!]!
  orderedByHighestErrorRatio: [TopOperationByNameAndHashOrderedByHighestErrorRatio!]!
  orderedByHighestLatency: [TopOperationByNameAndHashOrderedByHighestLatency!]!
}

type Trace {
  id: ID!
  rootSpanId: ID!
  spans: [TraceSpan!]!
}

type TraceSpan {
  attributes: JSON!
  endedAt: DateTime!
  id: ID!
  name: String!
  parentId: ID
  startedAt: DateTime!
  statusCode: TraceSpanStatusCode
}

enum TraceSpanStatusCode {
  ERROR
  OK
}

type TrialPlanUnavailableError {
  query: Query!
}

type TrustedDocument {
  documentId: String!
  documentText: String!
}

input TrustedDocumentInput {
  documentId: String!
  documentText: String!
}

union TrustedDocumentsSubmitPayload = GraphDoesNotExistError | OldAccessTokenError | ProjectDoesNotExistError | ReusedIds | TrustedDocumentsSubmitSuccess

type TrustedDocumentsSubmitSuccess {
  count: Int!
  documents: [TrustedDocument!]!
}

enum UnitType {
  NO_UNIT
  MILLI_SECONDS
  BYTES
}

scalar Url

type User implements Node {
  avatarUrl: String
  canStartNewTrial: Boolean!
  createdAt: DateTime!
  email: String!
  id: ID!
  name: String!
  organizationMemberships: [Member!]!
  organizations(after: String, before: String, first: Int, last: Int): OrganizationConnection!
  personalAccount: PersonalAccount
}

type UserConnection {
  edges: [UserEdge!]!
  nodes: [User!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserEdge {
  cursor: String!
  node: User!
  role: TeamRole!
}

type ValidationCheckError {
  message: String!
  title: String!
}

type ValueTooLongError {
  query: Query!
}

