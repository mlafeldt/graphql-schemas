schema {
  query: QueryRoot
  mutation: MutationRoot
}

interface Account {
  id: ID!
  slug: String!
  name: String!
  createdAt: DateTime!
  projects(after: String, before: String, first: Int, last: Int): ProjectConnection!
}

type Branch {
  id: ID!
  name: String!
  domains: [String!]!
  latestDeployment: Deployment
  activeDeployment: Deployment
  deployments(after: String, before: String, first: Int, last: Int): DeploymentConnection!
}

type BranchConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BranchEdge]
}

"""An edge in a connection."""
type BranchEdge {
  """The item at the end of the edge"""
  node: Branch!

  """A cursor for use in pagination"""
  cursor: String!
}

type BranchMetrics {
  latency: Distribution!
  request: Distribution!
}

"""
Implement the DateTime scalar

The input/output is a string in RFC3339 format, with "Z" suffix instead of "+00:00"
Implementation is based on
[async_graphql::types::external::datetime](https://github.com/async-graphql/async-graphql/blob/5d03592d98f41ad00a792ff131304497e6161fa1/src/types/external/datetime.rs)
"""
scalar DateTime

"""Deployment"""
type Deployment {
  id: ID!
  commit: GitCommit!
  branch: String!
  createdAt: DateTime!
  status: DeploymentStatus!
  logEntries: [DeploymentLogEntry!]!
}

type DeploymentConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [DeploymentEdge]
}

"""An edge in a connection."""
type DeploymentEdge {
  """The item at the end of the edge"""
  node: Deployment!

  """A cursor for use in pagination"""
  cursor: String!
}

type DeploymentLogEntry {
  createdAt: DateTime!
  message: String!
}

enum DeploymentStatus {
  PENDING
  IN_PROGRESS
  ACTIVE
  INACTIVE
  FAILED
}

type Distribution {
  unit: UnitType!
  values: [DistributionValue!]!
}

type DistributionValue {
  bucket: DateTime!
  value: Int!
}

type EnvironmentVariable {
  id: ID!
  key: String!
  value: String!
  createdAt: DateTime!
}

input EnvironmentVariableCreateInput {
  environmentId: ID!

  """Must not be already assigned."""
  key: String!

  """Must not start with `GRAFBASE_`."""
  value: String!
}

type EnvironmentVariableCreatePayload {
  environmentVariable: EnvironmentVariable!
  query: QueryRoot!
}

input EnvironmentVariableDeleteInput {
  id: ID!
}

type EnvironmentVariableDeletePayload {
  deletedId: ID!
  query: QueryRoot!
}

input EnvironmentVariableUpdateInput {
  id: ID!

  """Must not be already assigned."""
  key: String!

  """Must not start with `GRAFBASE_`."""
  value: String!
}

type EnvironmentVariableUpdatePayload {
  environmentVariable: EnvironmentVariable!
  query: QueryRoot!
}

type GitAccount {
  provider: GitProvider!
  id: ID!
  slug: String!
}

type GitCommit {
  sha: String!
  message: String!
  author: String
  authorAvatarUrl: String
  committer: String
  committerAvatarUrl: String
}

enum GitProvider {
  GITHUB
}

type GitRepository {
  provider: GitProvider!
  id: String!
  owner: String!
  slug: String!
  url: String!
  defaultBranch: String
  private: Boolean!
  updatedAt: DateTime!
}

type Invite {
  id: ID!
  role: MemberRole!
  email: String!
  invitedBy: User!
  lastRenewedAt: DateTime!
  status: InviteStatus!
  createdAt: DateTime!
  organization: Organization!
}

input InviteAcceptInput {
  id: ID!
}

type InviteAcceptPayload {
  member: Member!
  query: QueryRoot!
}

input InviteCancelInput {
  id: ID!
}

type InviteCancelPayload {
  id: ID!
  query: QueryRoot!
}

type InviteConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [InviteEdge]
}

input InviteDeclineInput {
  id: ID!
}

type InviteDeclinePayload {
  id: ID!
  query: QueryRoot!
}

"""An edge in a connection."""
type InviteEdge {
  """The item at the end of the edge"""
  node: Invite!

  """A cursor for use in pagination"""
  cursor: String!
}

input InviteSendInput {
  organizationId: ID!
  email: String!
  role: MemberRole!
}

type InviteSendPayload {
  invite: Invite!
  query: QueryRoot!
}

enum InviteStatus {
  PENDING
  EXPIRED
}

input LoginInput {
  inviteId: ID
}

type LoginPayload {
  user: User!
  isFirstLogin: Boolean!
  query: QueryRoot!
}

type Member {
  id: ID!
  role: MemberRole!
  createdAt: DateTime!
  account: Account!
  user: User!
}

type MemberConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [MemberEdge]
}

input MemberDeleteInput {
  id: ID!
}

type MemberDeletePayload {
  deletedMemberId: ID!
  query: QueryRoot!
}

"""An edge in a connection."""
type MemberEdge {
  """The item at the end of the edge"""
  node: Member!

  """A cursor for use in pagination"""
  cursor: String!
}

enum MemberRole {
  OWNER
  MEMBER
}

input MemberUpdateInput {
  id: ID!
  role: MemberRole
}

type MemberUpdatePayload {
  member: Member!
  query: QueryRoot!
}

type MutationRoot {
  """
  Create new organization account owned by the current user. Slug must be unique.
  """
  organizationCreate(input: OrganizationCreateInput!): OrganizationCreatePayload!
  personalAccountDelete: PersonalAccountDeletePayload!
  organizationDelete(input: OrganizationDeleteInput!): OrganizationDeletePayload!

  """Create new environment variable for the targeted Environment"""
  environmentVariableCreate(input: EnvironmentVariableCreateInput!): EnvironmentVariableCreatePayload!

  """
  Update an environment variable.
  Mocked up.
  """
  environmentVariableUpdate(input: EnvironmentVariableUpdateInput!): EnvironmentVariableUpdatePayload!

  """
  Delete an environment variable.
  Mocked up.
  """
  environmentVariableDelete(input: EnvironmentVariableDeleteInput!): EnvironmentVariableDeletePayload!

  """Update role of an organization member"""
  memberUpdate(input: MemberUpdateInput!): MemberUpdatePayload!

  """Remove member from an organization"""
  memberDelete(input: MemberDeleteInput!): MemberDeletePayload!

  """
  Create new project owned by the current user. Slug must be unique for given account.
  """
  projectCreateFromRepo(input: ProjectCreateFromRepoInput!): ProjectCreateFromRepoPayload!
  projectUpdate(input: ProjectUpdateInput!): ProjectUpdatePayload!
  projectDelete(input: ProjectDeleteInput!): ProjectDeletePayload!
  login(input: LoginInput): LoginPayload!
  inviteSend(input: InviteSendInput!): InviteSendPayload!
  inviteCancel(input: InviteCancelInput!): InviteCancelPayload!
  inviteAccept(input: InviteAcceptInput!): InviteAcceptPayload!
  inviteDecline(input: InviteDeclineInput!): InviteDeclinePayload!
}

type NameSizeCheckError {
  maxLength: Int!
  message: String!
}

type Organization implements Account {
  id: ID!
  slug: String!
  name: String!
  createdAt: DateTime!
  projects(after: String, before: String, first: Int, last: Int): ProjectConnection!
  invites(after: String, before: String, first: Int, last: Int): InviteConnection!
  members(after: String, before: String, first: Int, last: Int): MemberConnection!
}

type OrganizationConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [OrganizationEdge]
}

input OrganizationCreateInput {
  slug: String!
  name: String!
}

union OrganizationCreatePayload = OrganizationCreateSuccess | SlugError | SlugSizeCheckError | NameSizeCheckError | ReservedSlugsCheckError

type OrganizationCreateSuccess {
  organization: Organization!
  member: Member!
  query: QueryRoot!
}

input OrganizationDeleteInput {
  id: ID!
}

type OrganizationDeletePayload {
  deletedId: ID!
  query: QueryRoot!
}

"""An edge in a connection."""
type OrganizationEdge {
  """The item at the end of the edge"""
  node: Organization!

  """A cursor for use in pagination"""
  cursor: String!
}

"""Information about pagination in a connection"""
type PageInfo {
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type PersonalAccount implements Account {
  id: ID!
  slug: String!
  name: String!
  createdAt: DateTime!
  projects(after: String, before: String, first: Int, last: Int): ProjectConnection!
}

type PersonalAccountDeletePayload {
  deletedId: ID!
}

type Project {
  id: ID!
  slug: String!
  createdAt: DateTime!
  repository: GitRepository!
  branches(after: String, before: String, first: Int, last: Int): BranchConnection!
  productionBranch: String!
}

type ProjectConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ProjectEdge]
}

input ProjectCreateFromRepoInput {
  accountId: ID!
  projectSlug: String!
  gitRepoUrl: Url!
  gitAccountId: String!
  productionBranch: String!
}

type ProjectCreateFromRepoPayload {
  project: Project!
  query: QueryRoot!
}

input ProjectDeleteInput {
  id: ID!
}

type ProjectDeletePayload {
  query: QueryRoot!
}

"""An edge in a connection."""
type ProjectEdge {
  """The item at the end of the edge"""
  node: Project!

  """A cursor for use in pagination"""
  cursor: String!
}

input ProjectUpdateInput {
  id: ID!
  projectSlug: String
  productionBranch: String
}

type ProjectUpdatePayload {
  project: Project!
  query: QueryRoot!
}

type QueryRoot {
  accountBySlug(
    """slug of the account"""
    slug: String!
  ): Account
  metricsByBranch(accountId: ID!, projectSlug: ID!, branch: ID!, startDate: DateTime!, endDate: DateTime!): BranchMetrics!

  """Return a list of git accounts accessible by the current user."""
  gitAccounts(provider: GitProvider!): [GitAccount!]!

  """
  Return a list of git repositories accessible by the current user, sorted by updatedAt.
  With `query` specified, the list will include up to 10 repos matching the query.
  Without `query`, the list will include the 10 most recently updated repos.
  """
  gitRepos(provider: GitProvider!, gitAccountId: String!, query: String): [GitRepository!]!

  """Returns details about a specific git repository identified by its URL."""
  gitRepoByUrl(url: Url!): GitRepository!

  """Get project by account slug and slug of the project itself."""
  projectByAccountSlug(
    """slug of the account"""
    accountSlug: String!

    """slug of the project"""
    projectSlug: String!
  ): Project

  """Give the actual connected user."""
  viewer: User
  invite(id: ID!): Invite
}

type ReservedSlugsCheckError {
  message: String!
}

type SlugError {
  message: String!
  actual: String!
  expected: String!
}

type SlugSizeCheckError {
  maxLength: Int!
  message: String!
}

enum UnitType {
  NO_UNIT
  MILLI_SECONDS
}

"""
URL is a String implementing the [URL Standard](http://url.spec.whatwg.org/)
"""
scalar Url

type User {
  id: ID!
  name: String!
  email: String!
  avatarUrl: String
  createdAt: DateTime!
  organizations(after: String, before: String, first: Int, last: Int): OrganizationConnection!
  organizationMemberships: [Member!]!
  personalAccount: PersonalAccount!
}

