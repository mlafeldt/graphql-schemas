"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

"""An API key. Grants access to the user's resources."""
type ApiKey implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The label of the API key."""
  label: String!
}

type ApiKeyConnection {
  edges: [ApiKeyEdge!]!
  nodes: [ApiKey!]!
  pageInfo: PageInfo!
}

input ApiKeyCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The label for the API key."""
  label: String!

  """The API key value."""
  key: String!
}

type ApiKeyEdge {
  node: ApiKey!

  """Used in `before` and `after` args"""
  cursor: String!
}

type ApiKeyPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The API key that was created."""
  apiKey: ApiKey!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Public information of the OAuth application."""
type Application {
  """OAuth application's client ID."""
  clientId: String!

  """Application name."""
  name: String!

  """Information about the application."""
  description: String

  """Name of the developer."""
  developer: String!

  """Url of the developer (homepage or docs)."""
  developerUrl: String!

  """Image of the application."""
  imageUrl: String
}

type ArchivePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Contains requested archived model objects."""
type ArchiveResponse {
  """A JSON serialized collection of model objects loaded from the archive"""
  archive: String!

  """The total number of entities in the archive."""
  totalCount: Float!

  """
  The version of the remote database. Incremented by 1 for each migration run on the database.
  """
  databaseVersion: Float!

  """
  Whether the dependencies for the model objects are included in the archive.
  """
  includesDependencies: Boolean!
}

"""[Alpha] Issue attachment (e.g. support ticket, pull request)."""
type Attachment implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """Content for the title line in the Linear attachment widget."""
  title: String!

  """Content for the subtitle line in the Linear attachment widget."""
  subtitle: String

  """Location of the attachment which is also used as an identifier."""
  url: String!

  """The creator of the attachment."""
  creator: User

  """Custom metadata related to the attachment."""
  metadata: JSONObject!

  """Information about the source which created the attachment."""
  source: JSONObject

  """
  An accessor helper to source.type, defines the source type of the attachment.
  """
  sourceType: JSONObject

  """
  Indicates if attachments for the same source application should be grouped in the Linear UI.
  """
  groupBySource: Boolean!

  """The issue this attachment belongs to."""
  issue: Issue!
}

type AttachmentConnection {
  edges: [AttachmentEdge!]!
  nodes: [Attachment!]!
  pageInfo: PageInfo!
}

input AttachmentCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The attachment title."""
  title: String!

  """The attachment subtitle."""
  subtitle: String

  """
  Attachment location which is also used as an unique identifier for the
  attachment. If another attachment is created with the same `url` value,
  existing record is updated instead.
  """
  url: String!

  """The issue to associate the attachment with."""
  issueId: String!

  """
  An icon url to display with the attachment. Should be of jpg or png format.
  Maximum of 1MB in size. Dimensions should be 20x20px for optimal display quality.
  """
  iconUrl: String

  """Attachment metadata object with string and number values."""
  metadata: JSONObject

  """
  Indicates if attachments for the same source application should be grouped in the Linear UI.
  """
  groupBySource: Boolean

  """Create a linked comment with markdown body."""
  commentBody: String

  """
  [Internal] Create a linked comment with Prosemirror body. Please use `commentBody` instead
  """
  commentBodyData: JSONObject

  """
  Create attachment as a user with the provided name. This option is only
  available to OAuth applications creating attachments in `actor=application` mode.
  """
  createAsUser: String
}

type AttachmentEdge {
  node: Attachment!

  """Used in `before` and `after` args"""
  cursor: String!
}

"""[Alpha] Attachment filtering options."""
input AttachmentFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the title."""
  title: StringComparator

  """Comparator for the subtitle."""
  subtitle: NullableStringComparator

  """Comparator for the url."""
  url: StringComparator

  """Filters that the attachments creator must satisfy."""
  creator: NullableUserFilter

  """Comparator for the source type."""
  sourceType: NestedStringComparator
}

type AttachmentPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The issue attachment that was created."""
  attachment: Attachment!

  """Whether the operation was successful."""
  success: Boolean!
}

input AttachmentUpdateInput {
  """The attachment title."""
  title: String!

  """The attachment subtitle."""
  subtitle: String

  """Attachment metadata object with string and number values."""
  metadata: JSONObject

  """
  An icon url to display with the attachment. Should be of jpg or png format.
  Maximum of 1MB in size. Dimensions should be 20x20px for optimal display quality.
  """
  iconUrl: String
}

"""Workspace audit log entry object."""
type AuditEntry implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime
  type: String!

  """The user that caused the audit entry to be created."""
  actor: User

  """The ID of the user that caused the audit entry to be created."""
  actorId: String

  """IP from actor when entry was recorded."""
  ip: String

  """Country code of request resulting to audit entry."""
  countryCode: String

  """Additional metadata related to the audit entry."""
  metadata: JSONObject
}

type AuditEntryConnection {
  edges: [AuditEntryEdge!]!
  nodes: [AuditEntry!]!
  pageInfo: PageInfo!
}

type AuditEntryEdge {
  node: AuditEntry!

  """Used in `before` and `after` args"""
  cursor: String!
}

"""[Alpha] Audit entry filtering options."""
input AuditEntryFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the type."""
  type: StringComparator

  """Comparator for the IP address."""
  ip: StringComparator

  """Comparator for the country code."""
  countryCode: StringComparator

  """Filters that the audit entry actor must satisfy."""
  actor: NullableUserFilter
}

type AuditEntryType {
  """The audit entry type."""
  type: String!

  """Description of the audit entry type."""
  description: String!
}

"""
Public information of the OAuth application, plus the authorized scopes for a given user.
"""
type AuthorizedApplication {
  """OAuth application's client ID."""
  clientId: String!

  """Application name."""
  name: String!

  """Information about the application."""
  description: String

  """Name of the developer."""
  developer: String!

  """Url of the developer (homepage or docs)."""
  developerUrl: String!

  """Image of the application."""
  imageUrl: String

  """Scopes that are authorized for this application for a given user."""
  scope: [String!]!

  """OAuth application's ID."""
  appId: String!

  """Whether or not webhooks are enabled for the application."""
  webhooksEnabled: Boolean!
}

type AuthResolverResponse {
  """User account ID."""
  id: String!

  """JWT token for authentication of the account."""
  token: String

  """Email for the authenticated account."""
  email: String

  """Should the signup flow allow access for the domain."""
  allowDomainAccess: Boolean

  """Users belonging to this account."""
  users: [User!]!

  """Organizations this account has access to, but is not yet a member."""
  availableOrganizations: [Organization!]

  """ID of the organization last accessed by the user."""
  lastUsedOrganizationId: String
}

"""Relation load request."""
input BatchRequest {
  """The class name of the model to load."""
  modelClass: String!

  """The indexed key to load models for."""
  indexedKey: String!

  """The value of the indexed key to load models for."""
  keyValue: String!
}

type BillingDetailsPayload {
  """Whether the operation was successful."""
  success: Boolean!

  """The customer's email address the invoices are sent to."""
  email: String

  """List of invoices, if any."""
  invoices: [Invoice!]!

  """The payment method."""
  paymentMethod: Card
}

type BillingEmailPayload {
  """Whether the operation was successful."""
  success: Boolean!

  """The customer's email address the invoices are sent to."""
  email: String
}

input BillingEmailUpdateInput {
  """The email address to which to send invoices."""
  email: String!
}

"""Comparator for booleans."""
input BooleanComparator {
  """Equals constraint."""
  eq: Boolean

  """Not equals constraint."""
  neq: Boolean
}

type Card {
  """The brand of the card, e.g. Visa."""
  brand: String!

  """The last four digits used to identify the card."""
  last4: String!
}

input CollaborationDocumentUpdateInput {
  """Document identifier."""
  issueId: String!

  """Client's document version number."""
  version: Int!

  """New document steps from the client."""
  steps: [JSON!]!

  """Client identifier."""
  clientId: String!
}

type CollaborationDocumentUpdatePayload {
  """
  Document steps the client has not seen yet and need to rebase it's local steps on.
  """
  steps: StepsResponse

  """Whether the operation was successful."""
  success: Boolean!
}

"""A comment associated with an issue."""
type Comment implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The comment content in markdown format."""
  body: String!

  """The issue that the comment is associated with."""
  issue: Issue!

  """The parent of the comment."""
  parent: Comment

  """The user who wrote the comment."""
  user: User

  """The time user edited the comment."""
  editedAt: DateTime

  """Comment's URL."""
  url: String!

  """The children of the comment."""
  children(
    """[Alpha] Filter returned comments."""
    filter: CommentFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CommentConnection!
}

"""[Alpha] Comment filtering options."""
input CommentCollectionFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the comments body."""
  body: StringComparator

  """Filters that the comments creator must satisfy."""
  user: UserFilter

  """Filters that the comments issue must satisfy."""
  issue: IssueFilter

  """Compound filters, all of which need to be matched by the comment."""
  and: [CommentFilter!]

  """Compound filters, one of which need to be matched by the comment."""
  or: [CommentFilter!]

  """Filters that needs to be matched by some comments."""
  some: CommentFilter

  """Filters that needs to be matched by all comments."""
  every: CommentFilter
}

type CommentConnection {
  edges: [CommentEdge!]!
  nodes: [Comment!]!
  pageInfo: PageInfo!
}

input CommentCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The comment content in markdown format."""
  body: String

  """The comment content as a Prosemirror document."""
  bodyData: JSON

  """The issue to associate the comment with."""
  issueId: String!

  """[Internal] The parent under which to nest the comment."""
  parentId: String

  """
  Create comment as a user with the provided name. This option is only available
  to OAuth applications creating comments in `actor=application` mode.
  """
  createAsUser: String
}

type CommentEdge {
  node: Comment!

  """Used in `before` and `after` args"""
  cursor: String!
}

"""[Alpha] Comment filtering options."""
input CommentFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the comments body."""
  body: StringComparator

  """Filters that the comments creator must satisfy."""
  user: UserFilter

  """Filters that the comments issue must satisfy."""
  issue: IssueFilter

  """Compound filters, all of which need to be matched by the comment."""
  and: [CommentFilter!]

  """Compound filters, one of which need to be matched by the comment."""
  or: [CommentFilter!]
}

type CommentPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The comment that was created or updated."""
  comment: Comment!

  """Whether the operation was successful."""
  success: Boolean!
}

input CommentUpdateInput {
  """The comment content."""
  body: String

  """The comment content as a Prosemirror document."""
  bodyData: JSON
}

"""GitHub's commit data"""
type CommitPayload {
  id: String!
  message: String!
  timestamp: String!
  url: String!
  added: [String!]!
  removed: [String!]!
  modified: [String!]!
}

input ContactCreateInput {
  """The type of support contact."""
  type: String!

  """The message the user sent."""
  message: String!

  """User's operating system."""
  operatingSystem: String

  """User's browser information."""
  browser: String

  """User's device information."""
  device: String

  """User's Linear client information."""
  clientVersion: String

  """How disappointed the user would be if they could no longer use Linear."""
  disappointmentRating: Int
}

type ContactPayload {
  """Whether the operation was successful."""
  success: Boolean!
}

type CreateCsvExportReportPayload {
  """Whether the operation was successful."""
  success: Boolean!
}

input CreateOrganizationInput {
  """The name of the organization."""
  name: String!

  """The URL key of the organization."""
  urlKey: String!

  """Whether the organization should allow email domain access."""
  domainAccess: Boolean

  """The timezone of the organization, passed in by client."""
  timezone: String

  """
  JSON serialized UTM parameters associated with the creation of the workspace.
  """
  utm: String
}

type CreateOrJoinOrganizationResponse {
  organization: Organization!
  user: User!
}

"""A custom view that has been saved by a user."""
type CustomView implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The name of the custom view."""
  name: String!

  """The description of the custom view."""
  description: String

  """The icon of the custom view."""
  icon: String

  """The color of the icon of the custom view."""
  color: String

  """The organization of the custom view."""
  organization: Organization!

  """The team associated with the custom view."""
  team: Team

  """The user who created the custom view."""
  creator: User!

  """The filters applied to issues in the custom view."""
  filters: JSONObject! @deprecated(reason: "Will be replaced by `filterData` in a future update")

  """[Alpha] The filter applied to issues in the custom view."""
  filterData: JSONObject!

  """Whether the custom view is shared with everyone in the organization."""
  shared: Boolean!
}

type CustomViewConnection {
  edges: [CustomViewEdge!]!
  nodes: [CustomView!]!
  pageInfo: PageInfo!
}

input CustomViewCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The name of the custom view."""
  name: String!

  """The description of the custom view."""
  description: String

  """The icon of the custom view."""
  icon: String

  """The color of the icon of the custom view."""
  color: String

  """The id of the team associated with the custom view."""
  teamId: String

  """The filters applied to issues in the custom view."""
  filters: JSONObject

  """The filter applied to issues in the custom view."""
  filterData: JSONObject

  """Whether the custom view is shared with everyone in the organization."""
  shared: Boolean
}

type CustomViewEdge {
  node: CustomView!

  """Used in `before` and `after` args"""
  cursor: String!
}

type CustomViewPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The custom view that was created or updated."""
  customView: CustomView!

  """Whether the operation was successful."""
  success: Boolean!
}

input CustomViewUpdateInput {
  """The name of the custom view."""
  name: String

  """The description of the custom view."""
  description: String

  """The icon of the custom view."""
  icon: String

  """The color of the icon of the custom view."""
  color: String

  """The id of the team associated with the custom view."""
  teamId: String

  """The filters applied to issues in the custom view."""
  filters: JSONObject

  """The filter applied to issues in the custom view."""
  filterData: JSONObject

  """Whether the custom view is shared with everyone in the organization."""
  shared: Boolean
}

"""A set of issues to be resolved in a specified amount of time."""
type Cycle implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The number of the cycle."""
  number: Float!

  """The custom name of the cycle."""
  name: String

  """The start time of the cycle."""
  startsAt: DateTime!

  """The end time of the cycle."""
  endsAt: DateTime!

  """
  The completion time of the cycle. If null, the cycle hasn't been completed.
  """
  completedAt: DateTime

  """
  The time at which the cycle was automatically archived by the auto pruning process.
  """
  autoArchivedAt: DateTime

  """The total number of issues in the cycle after each day."""
  issueCountHistory: [Float!]!

  """The number of completed issues in the cycle after each day."""
  completedIssueCountHistory: [Float!]!

  """The total number of estimation points after each day."""
  scopeHistory: [Float!]!

  """The number of completed estimation points after each day."""
  completedScopeHistory: [Float!]!

  """The team that the cycle is associated with."""
  team: Team!

  """Issues associated with the cycle."""
  issues(
    """[Alpha] Filter returned issues."""
    filter: IssueFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """Issues that weren't completed when the cycle was closed."""
  uncompletedIssuesUponClose(
    """[Alpha] Filter returned issues."""
    filter: IssueFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """
  The overall progress of the cycle. This is the (completed estimate points +
  0.25 * in progress estimate points) / total estimate points.
  """
  progress: Float!
}

type CycleConnection {
  edges: [CycleEdge!]!
  nodes: [Cycle!]!
  pageInfo: PageInfo!
}

input CycleCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The custom name of the cycle."""
  name: String

  """The team to associate the cycle with."""
  teamId: String!

  """The start date of the cycle."""
  startsAt: DateTime!

  """The end date of the cycle."""
  endsAt: DateTime!

  """
  The completion time of the cycle. If null, the cycle hasn't been completed.
  """
  completedAt: DateTime
}

type CycleEdge {
  node: Cycle!

  """Used in `before` and `after` args"""
  cursor: String!
}

"""[Alpha] Project filtering options."""
input CycleFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the cycle number."""
  number: NumberComparator

  """Comparator for the cycle name."""
  name: StringComparator

  """Comparator for the cycle start date."""
  startsAt: DateComparator

  """Comparator for the cycle ends at date."""
  endsAt: DateComparator

  """Comparator for the cycle completed at date."""
  completedAt: DateComparator

  """Filters that the cycles team must satisfy."""
  team: TeamFilter

  """Filters that the cycles issues must satisfy."""
  issues: IssueCollectionFilter

  """Compound filters, all of which need to be matched by the cycle."""
  and: [CycleFilter!]

  """Compound filters, one of which need to be matched by the cycle."""
  or: [CycleFilter!]
}

type CyclePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The Cycle that was created or updated."""
  cycle: Cycle

  """Whether the operation was successful."""
  success: Boolean!
}

input CycleUpdateInput {
  """The custom name of the cycle."""
  name: String

  """The start date of the cycle."""
  startsAt: DateTime

  """The end date of the cycle."""
  endsAt: DateTime

  """The end date of the cycle."""
  completedAt: DateTime
}

"""Comparator for dates."""
input DateComparator {
  """Equals constraint."""
  eq: DateTime

  """Not-equals constraint."""
  neq: DateTime

  """In-array constraint."""
  in: [DateTime!]

  """Not-in-array constraint."""
  nin: [DateTime!]

  """
  Less-than constraint. Matches any values that are less than the given value.
  """
  lt: DateTime

  """
  Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
  """
  lte: DateTime

  """
  Greater-than constraint. Matches any values that are greater than the given value.
  """
  gt: DateTime

  """
  Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
  """
  gte: DateTime
}

"""
Represents a date and time in ISO 8601 format. Accepts shortcuts like `2021` to
represent midnight Fri Jan 01 2021. Also accepts ISO 8601 durations strings
which are added to the current date to create the represented date (e.g '-P2W1D'
represents the date that was two weeks and 1 day ago) 
"""
scalar DateTime

type DebugPayload {
  """Whether the operation was successful."""
  success: Boolean!
}

input DeleteOrganizationInput {
  """The deletion code to confirm operation."""
  deletionCode: String!
}

"""Contains the requested dependencies."""
type DependencyResponse {
  """A JSON serialized collection of dependencies."""
  dependencies: String!
}

"""A document for a project."""
type Document implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The document title."""
  title: String!

  """The document content in markdown format."""
  content: String

  """The document content as JSON."""
  contentData: JSONObject

  """The icon of the document."""
  icon: String

  """The color of the icon."""
  color: String

  """The user who created the document."""
  creator: User!

  """The user who last updated the document."""
  updatedBy: User!

  """The project that the document is associated with."""
  project: Project!

  """The document's unique URL slug."""
  slugId: String!
}

type DocumentConnection {
  edges: [DocumentEdge!]!
  nodes: [Document!]!
  pageInfo: PageInfo!
}

input DocumentCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The title of the document."""
  title: String!

  """The icon of the document."""
  icon: String

  """The color of the icon."""
  color: String

  """[Internal] The document content as a Prosemirror document."""
  contentData: JSONObject

  """The document content as markdown."""
  content: String

  """Related project for the document."""
  projectId: String!
}

type DocumentEdge {
  node: Document!

  """Used in `before` and `after` args"""
  cursor: String!
}

type DocumentPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The document that was created or updated."""
  document: Document!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Collaborative editing steps for documents."""
type DocumentStep implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """Step data."""
  step: JSON!

  """Step version."""
  version: Float!

  """Connected client ID."""
  clientId: String!
}

input DocumentUpdateInput {
  """The title of the document."""
  title: String

  """The icon of the document."""
  icon: String

  """The color of the icon."""
  color: String

  """[Internal] The document content as a Prosemirror document."""
  contentData: JSONObject

  """The document content as markdown."""
  content: String

  """Related project for the document."""
  projectId: String
}

"""A version of a document."""
type DocumentVersion implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The document's title."""
  title: String!

  """The version revision number."""
  revision: Float!

  """The document's content in markdown format."""
  content: String

  """The user who created the version."""
  creator: User!

  """The project that the document is associated with."""
  project: Project!
}

type DocumentVersionConnection {
  edges: [DocumentVersionEdge!]!
  nodes: [DocumentVersion!]!
  pageInfo: PageInfo!
}

type DocumentVersionEdge {
  node: DocumentVersion!

  """Used in `before` and `after` args"""
  cursor: String!
}

input EmailSubscribeInput {
  """Email to subscribe."""
  email: String!
}

type EmailSubscribePayload {
  """Whether the operation was successful."""
  success: Boolean!
}

input EmailUnsubscribeInput {
  """Email type to unsubscribed from."""
  type: String!

  """The user's email validation token."""
  token: String!

  """The identifier of the user."""
  userId: String!
}

type EmailUnsubscribePayload {
  """Whether the operation was successful."""
  success: Boolean!
}

input EmailUserAccountAuthChallengeInput {
  """The email for which to generate the magic login code."""
  email: String!

  """Whether the login was requested from the desktop app."""
  isDesktop: Boolean

  """Auth code for the client initiating the sequence."""
  clientAuthCode: String

  """Signup code."""
  signupCode: String
}

type EmailUserAccountAuthChallengeResponse {
  """Whether the operation was successful."""
  success: Boolean!

  """
  Supported challenge for this user account. Can be either verificationCode or password.
  """
  authType: String!
}

"""A custom emoji."""
type Emoji implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The emoji's name."""
  name: String!

  """The emoji image URL."""
  url: String!

  """The source of the emoji."""
  source: String!

  """The user who created the emoji."""
  creator: User!

  """The organization that the emoji belongs to."""
  organization: Organization!
}

type EmojiConnection {
  edges: [EmojiEdge!]!
  nodes: [Emoji!]!
  pageInfo: PageInfo!
}

input EmojiCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The name of the custom emoji."""
  name: String!

  """The URL for the emoji."""
  url: String!
}

type EmojiEdge {
  node: Emoji!

  """Used in `before` and `after` args"""
  cursor: String!
}

type EmojiPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The emoji that was created."""
  emoji: Emoji!

  """Whether the operation was successful."""
  success: Boolean!
}

"""A basic entity."""
interface Entity {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime
}

input EventCreateInput {
  """The category of the event to create."""
  category: String!

  """The subject of the event."""
  subject: String!

  """The target identifier of the event."""
  targetId: String

  """The value of the event."""
  value: Float

  """Additional data of the event, encoded as JSON."""
  data: JSON
}

type EventPayload {
  """Whether the operation was successful."""
  success: Boolean!
}

"""User favorites presented in the sidebar."""
type Favorite implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The type of the favorite."""
  type: String!

  """The parent folder of the favorite."""
  parent: Favorite

  """The name of the folder. Only applies to favorites of type folder."""
  folderName: String

  """The favorited issue."""
  issue: Issue

  """The favorited project."""
  project: Project

  """The favorited team of the project."""
  projectTeam: Team

  """The favorited cycle."""
  cycle: Cycle

  """The favorited custom view."""
  customView: CustomView

  """The team of the favorited predefiend view. """
  predefinedViewTeam: Team

  """The type of favorited predefiend view."""
  predefinedViewType: String

  """The favorited document."""
  document: Document

  """The favorited label."""
  label: IssueLabel

  """The owner of the favorite."""
  user: User!

  """The order of the item in the favorites list."""
  sortOrder: Float!

  """Children of the favorite. Only applies to favorites of type folder."""
  children(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): FavoriteConnection!
}

type FavoriteConnection {
  edges: [FavoriteEdge!]!
  nodes: [Favorite!]!
  pageInfo: PageInfo!
}

input FavoriteCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The name of the favorite folder."""
  folderName: String

  """The parent folder of the favorite."""
  parentId: String

  """The identifier of the issue to favorite."""
  issueId: String

  """The identifier of the project to favorite."""
  projectId: String

  """The identifier of the project team to favorite."""
  projectTeamId: String

  """The type of the predefined view to favorite."""
  predefinedViewType: String

  """The identifier of team for the predefined view to favorite."""
  predefinedViewTeamId: String

  """The identifier of the cycle to favorite."""
  cycleId: String

  """The identifier of the custom view to favorite."""
  customViewId: String

  """The identifier of the document to favorite."""
  documentId: String

  """The identifier of the label to favorite."""
  labelId: String

  """The position of the item in the favorites list."""
  sortOrder: Float
}

type FavoriteEdge {
  node: Favorite!

  """Used in `before` and `after` args"""
  cursor: String!
}

type FavoritePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The object that was added as a favorite."""
  favorite: Favorite!

  """Whether the operation was successful."""
  success: Boolean!
}

input FavoriteUpdateInput {
  """The position of the item in the favorites list."""
  sortOrder: Float

  """The id of the folder to move the favorite under."""
  parentId: String

  """The name of the favorite folder."""
  folderName: String
}

input FeedbackCreateInput {
  """The feedback the user sent."""
  feedback: String!

  """
  How disappointed the user would be if he/she could no longer use Linear.
  """
  disappointmentRating: Float!
}

type FeedbackPayload {
  """Whether the operation was successful."""
  success: Boolean!
}

"""Object representing Figma preview information."""
type FigmaEmbed {
  """Figma file name."""
  name: String!

  """Date when the file was updated at the time of embedding."""
  lastModified: DateTime!

  """Node name."""
  nodeName: String

  """Figma screenshot URL."""
  url: String
}

type FigmaEmbedPayload {
  """Figma embed information."""
  figmaEmbed: FigmaEmbed

  """Whether the operation was successful."""
  success: Boolean!
}

type FrontAttachmentPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type GitHubCommitIntegrationPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The integration that was created or updated."""
  integration: Integration

  """Whether the operation was successful."""
  success: Boolean!

  """The webhook secret to provide to GitHub."""
  webhookSecret: String!
}

"""
GitHub OAuth token, plus information about the organizations the user is a member of.
"""
type GithubOAuthTokenPayload {
  """The OAuth token if the operation to fetch it was successful."""
  token: String

  """
  A list of the GitHub organizations the user is a member of with attached repositories.
  """
  organizations: [GithubOrg!]
}

"""Relevant information for the GitHub organization."""
type GithubOrg {
  """GitHub organization id."""
  id: String!

  """The name of the GitHub organization."""
  name: String!

  """The login for the GitHub organization."""
  login: String!

  """Repositories that the organization owns."""
  repositories: [GithubRepo!]!
}

"""Relevant information for the GitHub repository."""
type GithubRepo {
  """The id of the GitHub repository."""
  id: String!

  """The name of the GitHub repository."""
  name: String!
}

"""Google Sheets specific settings."""
type GoogleSheetsSettings {
  spreadsheetId: String!
  spreadsheetUrl: String!
  sheetId: Float!
  updatedIssuesAt: DateTime!
}

input GoogleSheetsSettingsInput {
  spreadsheetId: String!
  spreadsheetUrl: String!
  sheetId: Float!
  updatedIssuesAt: DateTime!
}

input GoogleUserAccountAuthInput {
  """Code returned from Google's OAuth flow."""
  code: String!

  """The URI to redirect the user to."""
  redirectUri: String

  """The timezone of the user's browser."""
  timezone: String!

  """The identifiers of the teams to auto-join."""
  teamIdsToJoin: [String!]

  """Signup code."""
  signupCode: String
}

"""Comparator for identifiers."""
input IDComparator {
  """Equals constraint."""
  eq: ID

  """Not-equals constraint."""
  neq: ID

  """In-array constraint."""
  in: [ID!]

  """Not-in-array constraint."""
  nin: [ID!]
}

type ImageUploadFromUrlPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The URL containing the image."""
  url: String

  """Whether the operation was successful."""
  success: Boolean!
}

"""An integration with an external service."""
type Integration implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The integration's type."""
  service: String!

  """The organization that the integration is associated with."""
  organization: Organization!

  """The team that the integration is associated with."""
  team: Team

  """The user that added the integration."""
  creator: User!
}

type IntegrationConnection {
  edges: [IntegrationEdge!]!
  nodes: [Integration!]!
  pageInfo: PageInfo!
}

type IntegrationEdge {
  node: Integration!

  """Used in `before` and `after` args"""
  cursor: String!
}

type IntegrationPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The integration that was created or updated."""
  integration: Integration

  """Whether the operation was successful."""
  success: Boolean!
}

"""An integration resource created by an external service."""
type IntegrationResource implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The integration's type."""
  resourceType: String!

  """The external service resource ID."""
  resourceId: String!

  """Detailed information about the external resource."""
  data: IntegrationResourceData!

  """The integration that the resource is associated with."""
  integration: Integration!

  """The issue that the resource is associated with."""
  issue: Issue!

  """
  Pull request information for GitHub pull requests and GitLab merge requests.
  """
  pullRequest: PullRequestPayload!
}

type IntegrationResourceConnection {
  edges: [IntegrationResourceEdge!]!
  nodes: [IntegrationResource!]!
  pageInfo: PageInfo!
}

"""Integration resource's payload"""
type IntegrationResourceData {
  """The payload for an IntegrationResource of type 'githubPullRequest'"""
  githubPullRequest: PullRequestPayload

  """The payload for an IntegrationResource of type 'gitlabMergeRequest'"""
  gitlabMergeRequest: PullRequestPayload

  """The payload for an IntegrationResource of type 'githubCommit'"""
  githubCommit: CommitPayload

  """The payload for an IntegrationResource of type 'sentryIssue'"""
  sentryIssue: SentryIssuePayload
}

type IntegrationResourceEdge {
  node: IntegrationResource!

  """Used in `before` and `after` args"""
  cursor: String!
}

"""The integration resource's settings"""
type IntegrationSettings {
  slackPost: SlackPostSettings
  slackProjectPost: SlackPostSettings
  googleSheets: GoogleSheetsSettings
  sentry: SentrySettings
  zendesk: ZendeskSettings
  intercom: IntercomSettings
  jira: JiraSettings
}

input IntegrationSettingsInput {
  slackPost: SlackPostSettingsInput
  slackProjectPost: SlackPostSettingsInput
  googleSheets: GoogleSheetsSettingsInput
  sentry: SentrySettingsInput
  zendesk: ZendeskSettingsInput
  intercom: IntercomSettingsInput
  jira: JiraSettingsInput
}

"""Intercom specific settings."""
type IntercomSettings {
  """
  Whether an internal message should be added when a Linear issue changes status
  (for status types except completed or canceled).
  """
  sendNoteOnStatusChange: Boolean

  """
  Whether an internal message should be added when someone comments on an issue.
  """
  sendNoteOnComment: Boolean
}

input IntercomSettingsInput {
  """
  Whether an internal message should be added when a Linear issue changes status
  (for status types except completed or canceled).
  """
  sendNoteOnStatusChange: Boolean

  """
  Whether an internal message should be added when someone comments on an issue.
  """
  sendNoteOnComment: Boolean
}

type Invoice {
  """The URL at which the invoice can be viewed or paid."""
  url: String

  """The creation date of the invoice."""
  created: DateTime!

  """The due date of the invoice."""
  dueDate: TimelessDate

  """The status of the invoice."""
  status: String!

  """The invoice total, in cents."""
  total: Float!
}

"""An issue."""
type Issue implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The issue's unique number."""
  number: Float!

  """The issue's title."""
  title: String!

  """The issue's description in markdown format."""
  description: String

  """The priority of the issue."""
  priority: Float!

  """The estimate of the complexity of the issue.."""
  estimate: Float

  """The order of the item in its column on the board."""
  boardOrder: Float! @deprecated(reason: "Will be removed in near future, please use `sortOrder` instead")

  """The order of the item in relation to other items in the organization."""
  sortOrder: Float!

  """The time at which the issue was moved into started state."""
  startedAt: DateTime

  """The time at which the issue was moved into completed state."""
  completedAt: DateTime

  """The time at which the issue was moved into canceled state."""
  canceledAt: DateTime

  """
  The time at which the issue was automatically closed by the auto pruning process.
  """
  autoClosedAt: DateTime

  """
  The time at which the issue was automatically archived by the auto pruning process.
  """
  autoArchivedAt: DateTime

  """The date at which the issue is due."""
  dueDate: TimelessDate

  """A flag that indicates whether the issue is in the trash bin."""
  trashed: Boolean

  """The time until an issue will be snoozed in Triage view."""
  snoozedUntilAt: DateTime

  """The team that the issue is associated with."""
  team: Team!

  """The cycle that the issue is associated with."""
  cycle: Cycle

  """The project that the issue is associated with."""
  project: Project

  """Previous identifiers of the issue if it has been moved between teams."""
  previousIdentifiers: [String!]!

  """The user who created the issue."""
  creator: User

  """The user to whom the issue is assigned to."""
  assignee: User

  """The user who snoozed the issue."""
  snoozedBy: User

  """The workflow state that the issue is associated with."""
  state: WorkflowState!

  """The parent of the issue."""
  parent: Issue

  """
  The order of the item in the sub-issue list. Only set if the issue has a parent.
  """
  subIssueSortOrder: Float

  """Label for the priority."""
  priorityLabel: String!

  """Issue's human readable identifier (e.g. ENG-123)."""
  identifier: String!

  """Issue URL."""
  url: String!

  """Suggested branch name for the issue."""
  branchName: String!

  """
  Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
  """
  customerTicketCount: Int!

  """Users who are subscribed to the issue."""
  subscribers(
    """[Alpha] Filter returned subscribers."""
    filter: UserFilter

    """Should query return disabled/suspended users (default: false)."""
    includeDisabled: Boolean

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): UserConnection!

  """Children of the issue."""
  children(
    """[Alpha] Filter returned issues."""
    filter: IssueFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """Comments associated with the issue."""
  comments(
    """[Alpha] Filter returned comments."""
    filter: CommentFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CommentConnection!

  """History entries associated with the issue."""
  history(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueHistoryConnection!

  """Labels associated with this issue."""
  labels(
    """[Alpha] Filter returned issue labels."""
    filter: IssueLabelFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueLabelConnection!

  """Integration resources for this issue."""
  integrationResources(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IntegrationResourceConnection!

  """Relations associated with this issue."""
  relations(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueRelationConnection!

  """Inverse relations associated with this issue."""
  inverseRelations(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueRelationConnection!

  """Attachments associated with the issue."""
  attachments(
    """[Alpha] Filter returned attachments."""
    filter: AttachmentFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): AttachmentConnection!
}

type IssueBatchPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The issues that were updated."""
  issues: [Issue!]!

  """Whether the operation was successful."""
  success: Boolean!
}

"""[Alpha] Issue filtering options."""
input IssueCollectionFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the issues number."""
  number: NumberComparator

  """Comparator for the issues title."""
  title: StringComparator

  """Comparator for the issues description."""
  description: NullableStringComparator

  """Comparator for the issues priority."""
  priority: NullableNumberComparator

  """Comparator for the issues estimate."""
  estimate: NumberComparator

  """Comparator for the issues started at date."""
  startedAt: NullableDateComparator

  """Comparator for the issues completed at date."""
  completedAt: NullableDateComparator

  """Comparator for the issues canceled at date."""
  canceledAt: NullableDateComparator

  """Comparator for the issues auto closed at date."""
  autoClosedAt: NullableDateComparator

  """Comparator for the issues auto archived at date."""
  autoArchivedAt: NullableDateComparator

  """Comparator for the issues due date."""
  dueDate: NullableTimelessDateComparator

  """Comparator for the issues snoozed until date."""
  snoozedUntilAt: NullableDateComparator

  """Filters that the issues assignee must satisfy."""
  assignee: NullableUserFilter

  """Filters that the issues creator must satisfy."""
  creator: NullableUserFilter

  """Filters that the issues snoozer must satisfy."""
  snoozedBy: NullableUserFilter

  """Filters that issue labels must satisfy."""
  labels: IssueLabelCollectionFilter

  """Filters that the issues team must satisfy."""
  team: TeamFilter

  """Filters that the issues comments must satisfy."""
  comments: CommentCollectionFilter

  """Filters that the issues cycle must satisfy."""
  cycle: NullableCycleFilter

  """Filters that the issues project must satisfy."""
  project: NullableProjectFilter

  """Filters that the issues state must satisfy."""
  state: WorkflowStateFilter

  """Filters that the child issues must satisfy."""
  children: IssueCollectionFilter

  """Filters that the issues attachments must satisfy."""
  attachments: AttachmentFilter

  """Compound filters, all of which need to be matched by the issue."""
  and: [IssueFilter!]

  """Compound filters, one of which need to be matched by the issue."""
  or: [IssueFilter!]

  """Filters that needs to be matched by some issues."""
  some: IssueFilter

  """Filters that needs to be matched by all issues."""
  every: IssueFilter
}

type IssueConnection {
  edges: [IssueEdge!]!
  nodes: [Issue!]!
  pageInfo: PageInfo!
}

input IssueCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The title of the issue."""
  title: String!

  """The issue description in markdown format."""
  description: String

  """The issue description as a Prosemirror document."""
  descriptionData: JSON

  """The identifier of the user to assign the issue to."""
  assigneeId: String

  """The identifier of the parent issue."""
  parentId: String

  """The priority of the issue."""
  priority: Int

  """The estimated complexity of the issue."""
  estimate: Int

  """The identifiers of the users subscribing to this ticket."""
  subscriberIds: [String!]

  """The identifiers of the issue labels associated with this ticket."""
  labelIds: [String!]

  """The identifier or key of the team associated with the issue."""
  teamId: String!

  """The cycle associated with the issue."""
  cycleId: String

  """The project associated with the issue."""
  projectId: String

  """The team state of the issue."""
  stateId: String

  """The comment the issue is referencing."""
  referenceCommentId: String

  """The position of the issue in its column on the board view."""
  boardOrder: Float

  """The position of the issue related to other issues."""
  sortOrder: Float

  """The position of the issue in parent's sub-issue list."""
  subIssueSortOrder: Float

  """The date at which the issue is due."""
  dueDate: TimelessDate

  """
  Create issue as a user with the provided name. This option is only available
  to OAuth applications creating issues in `actor=application` mode.
  """
  createAsUser: String
}

type IssueEdge {
  node: Issue!

  """Used in `before` and `after` args"""
  cursor: String!
}

"""[Alpha] Issue filtering options."""
input IssueFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the issues number."""
  number: NumberComparator

  """Comparator for the issues title."""
  title: StringComparator

  """Comparator for the issues description."""
  description: NullableStringComparator

  """Comparator for the issues priority."""
  priority: NullableNumberComparator

  """Comparator for the issues estimate."""
  estimate: NumberComparator

  """Comparator for the issues started at date."""
  startedAt: NullableDateComparator

  """Comparator for the issues completed at date."""
  completedAt: NullableDateComparator

  """Comparator for the issues canceled at date."""
  canceledAt: NullableDateComparator

  """Comparator for the issues auto closed at date."""
  autoClosedAt: NullableDateComparator

  """Comparator for the issues auto archived at date."""
  autoArchivedAt: NullableDateComparator

  """Comparator for the issues due date."""
  dueDate: NullableTimelessDateComparator

  """Comparator for the issues snoozed until date."""
  snoozedUntilAt: NullableDateComparator

  """Filters that the issues assignee must satisfy."""
  assignee: NullableUserFilter

  """Filters that the issues creator must satisfy."""
  creator: NullableUserFilter

  """Filters that the issues snoozer must satisfy."""
  snoozedBy: NullableUserFilter

  """Filters that issue labels must satisfy."""
  labels: IssueLabelCollectionFilter

  """Filters that the issues team must satisfy."""
  team: TeamFilter

  """Filters that the issues comments must satisfy."""
  comments: CommentCollectionFilter

  """Filters that the issues cycle must satisfy."""
  cycle: NullableCycleFilter

  """Filters that the issues project must satisfy."""
  project: NullableProjectFilter

  """Filters that the issues state must satisfy."""
  state: WorkflowStateFilter

  """Filters that the child issues must satisfy."""
  children: IssueCollectionFilter

  """Filters that the issues attachments must satisfy."""
  attachments: AttachmentFilter

  """Compound filters, all of which need to be matched by the issue."""
  and: [IssueFilter!]

  """Compound filters, one of which need to be matched by the issue."""
  or: [IssueFilter!]
}

"""A record of changes to an issue."""
type IssueHistory implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The issue that was changed."""
  issue: Issue!

  """
  The user who made these changes. If null, possibly means that the change made by an integration.
  """
  actor: User

  """
  Information about the integration or application which created this history entry.
  """
  source: JSONObject

  """Whether the issue's description was updated."""
  updatedDescription: Boolean

  """What the title was changed from."""
  fromTitle: String

  """What the title was changed to."""
  toTitle: String

  """The user from whom the issue was re-assigned from."""
  fromAssignee: User

  """The user to whom the issue was assigned to."""
  toAssignee: User

  """What the priority was changed from."""
  fromPriority: Float

  """What the priority was changed to."""
  toPriority: Float

  """The team from which the issue was moved from."""
  fromTeam: Team

  """The team to which the issue was moved to."""
  toTeam: Team

  """The previous parent of the issue."""
  fromParent: Issue

  """The new parent of the issue."""
  toParent: Issue

  """The previous workflow state of the issue."""
  fromState: WorkflowState

  """The new workflow state of the issue."""
  toState: WorkflowState

  """The previous cycle of the issue."""
  fromCycle: Cycle

  """The new cycle of the issue."""
  toCycle: Cycle

  """The previous project of the issue."""
  fromProject: Project

  """The new project of the issue."""
  toProject: Project

  """What the estimate was changed from."""
  fromEstimate: Float

  """What the estimate was changed to."""
  toEstimate: Float

  """Whether the issue was archived or un-archived."""
  archived: Boolean

  """Whether the issue was trashed or un-trashed."""
  trashed: Boolean

  """The import record."""
  issueImport: IssueImport

  """The linked attachment."""
  attachment: Attachment

  """ID's of labels that were added."""
  addedLabelIds: [String!]

  """ID's of labels that were removed."""
  removedLabelIds: [String!]

  """Changed issue relationships."""
  relationChanges: [IssueRelationHistoryPayload!]
  autoClosed: Boolean
  autoArchived: Boolean

  """What the due date was changed from"""
  fromDueDate: TimelessDate

  """What the due date was changed to"""
  toDueDate: TimelessDate
}

type IssueHistoryConnection {
  edges: [IssueHistoryEdge!]!
  nodes: [IssueHistory!]!
  pageInfo: PageInfo!
}

type IssueHistoryEdge {
  node: IssueHistory!

  """Used in `before` and `after` args"""
  cursor: String!
}

"""An import job for data from an external service"""
type IssueImport implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The id for the user that started the job."""
  creatorId: String!

  """The service from which data will be imported."""
  service: String!

  """The status for the import job."""
  status: String!

  """The data mapping configuration for the import job."""
  mapping: JSONObject

  """User readable error message, if one has occurred during the import."""
  error: String
}

type IssueImportDeletePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The import job that was deleted."""
  issueImport: IssueImport

  """Whether the operation was successful."""
  success: Boolean!
}

"""Issue import mapping input"""
input IssueImportMappingInput {
  """The mapping configuration for users"""
  users: JSONObject

  """The mapping configuration for workflow states"""
  workflowStates: JSONObject

  """The mapping configuration for epics"""
  epics: JSONObject
}

type IssueImportPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The import job that was created or updated."""
  issueImport: IssueImport

  """Whether the operation was successful."""
  success: Boolean!
}

input IssueImportUpdateInput {
  """The mapping configuration for the import."""
  mapping: JSONObject!
}

"""Labels that can be associated with issues."""
type IssueLabel implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The label's name."""
  name: String!

  """The label's description."""
  description: String

  """The label's color as a HEX string."""
  color: String!
  organization: Organization @deprecated(reason: "Workspace labels are identified by their team being null.")

  """
  The team that the label is associated with. If null, the label is associated with the global workspace..
  """
  team: Team

  """The user who created the label."""
  creator: User

  """Issues associated with the label."""
  issues(
    """[Alpha] Filter returned issues."""
    filter: IssueFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!
}

"""[Alpha] Issue label filtering options."""
input IssueLabelCollectionFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the name."""
  name: StringComparator

  """Filters that the issue labels creator must satisfy."""
  creator: NullableUserFilter

  """Filters that the issue labels team must satisfy."""
  team: TeamFilter

  """Compound filters, all of which need to be matched by the label."""
  and: [IssueLabelFilter!]

  """Compound filters, one of which need to be matched by the label."""
  or: [IssueLabelFilter!]

  """Filters that needs to be matched by some issue labels."""
  some: IssueLabelFilter

  """Filters that needs to be matched by all issue labels."""
  every: IssueLabelFilter
}

type IssueLabelConnection {
  edges: [IssueLabelEdge!]!
  nodes: [IssueLabel!]!
  pageInfo: PageInfo!
}

input IssueLabelCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The name of the label."""
  name: String!

  """The description of the label."""
  description: String

  """The color of the label."""
  color: String

  """
  The team associated with the label. If not given, the label will be associated with the entire workspace.
  """
  teamId: String
}

type IssueLabelEdge {
  node: IssueLabel!

  """Used in `before` and `after` args"""
  cursor: String!
}

"""[Alpha] Issue label filtering options."""
input IssueLabelFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the name."""
  name: StringComparator

  """Filters that the issue labels creator must satisfy."""
  creator: NullableUserFilter

  """Filters that the issue labels team must satisfy."""
  team: TeamFilter

  """Compound filters, all of which need to be matched by the label."""
  and: [IssueLabelFilter!]

  """Compound filters, one of which need to be matched by the label."""
  or: [IssueLabelFilter!]
}

type IssueLabelPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The label that was created or updated."""
  issueLabel: IssueLabel!

  """Whether the operation was successful."""
  success: Boolean!
}

input IssueLabelUpdateInput {
  """The name of the label."""
  name: String

  """The description of the label."""
  description: String

  """The color of the label."""
  color: String
}

"""An issue related notification"""
type IssueNotification implements Notification & Entity & Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """Notification type"""
  type: String!

  """The user that received the notification."""
  user: User!

  """
  The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  """
  readAt: DateTime

  """
  The time at when an email reminder for this notification was sent to the user. Null, if no email
      reminder has been sent.
  """
  emailedAt: DateTime

  """
  The time until a notification will be snoozed. After that it will appear in the inbox again.
  """
  snoozedUntilAt: DateTime

  """The issue related to the notification."""
  issue: Issue!

  """The team related to the notification."""
  team: Team!

  """The comment related to the notification."""
  comment: Comment

  """Name of the reaction emoji related to the notification."""
  reactionEmoji: String
}

type IssuePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The issue that was created or updated."""
  issue: Issue

  """Whether the operation was successful."""
  success: Boolean!
}

type IssuePriorityValue {
  """Priority's number value."""
  priority: Int!

  """Priority's label."""
  label: String!
}

"""A relation between two issues."""
type IssueRelation implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The relationship of the issue with the related issue."""
  type: String!

  """The issue whose relationship is being described."""
  issue: Issue!

  """The related issue."""
  relatedIssue: Issue!
}

type IssueRelationConnection {
  edges: [IssueRelationEdge!]!
  nodes: [IssueRelation!]!
  pageInfo: PageInfo!
}

input IssueRelationCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The type of relation of the issue to the related issue."""
  type: IssueRelationType!

  """The identifier of the issue that is related to another issue."""
  issueId: String!

  """The identifier of the related issue."""
  relatedIssueId: String!
}

type IssueRelationEdge {
  node: IssueRelation!

  """Used in `before` and `after` args"""
  cursor: String!
}

"""Issue relation history's payload"""
type IssueRelationHistoryPayload {
  """The identifier of the related issue."""
  identifier: String!

  """The type of the change."""
  type: String!
}

type IssueRelationPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The issue relation that was created or updated."""
  issueRelation: IssueRelation!

  """Whether the operation was successful."""
  success: Boolean!
}

"""The type of the issue relation."""
enum IssueRelationType {
  blocks
  duplicate
  related
}

input IssueRelationUpdateInput {
  """The type of relation of the issue to the related issue."""
  type: String

  """The identifier of the issue that is related to another issue."""
  issueId: String

  """The identifier of the related issue."""
  relatedIssueId: String
}

input IssueUpdateInput {
  """The issue title."""
  title: String

  """The issue description in markdown format."""
  description: String

  """The issue description as a Prosemirror document."""
  descriptionData: JSON

  """The identifier of the user to assign the issue to."""
  assigneeId: String

  """The identifier of the parent issue."""
  parentId: String

  """The priority of the issue."""
  priority: Int

  """The estimated complexity of the issue."""
  estimate: Int

  """The identifiers of the users subscribing to this ticket."""
  subscriberIds: [String!]

  """The identifiers of the issue labels associated with this ticket."""
  labelIds: [String!]

  """The identifier or key of the team associated with the issue."""
  teamId: String

  """The cycle associated with the issue."""
  cycleId: String

  """The project associated with the issue."""
  projectId: String

  """The team state of the issue."""
  stateId: String

  """The position of the issue in its column on the board view."""
  boardOrder: Float

  """The position of the issue related to other issues."""
  sortOrder: Float

  """The position of the issue in parent's sub-issue list."""
  subIssueSortOrder: Float

  """[DEPRECATED] Document version for backwards compatibility."""
  documentVersion: Int

  """The date at which the issue is due."""
  dueDate: TimelessDate

  """Wether the issue has been trashed."""
  trashed: Boolean

  """The time until an issue will be snoozed in Triage view."""
  snoozedUntilAt: DateTime

  """The identifier of the user who snoozed the issue."""
  snoozedById: String
}

input JiraConfigurationInput {
  """The Jira personal access token."""
  accessToken: String!

  """The Jira user's email address."""
  email: String!

  """The Jira installation hostname."""
  hostname: String!

  """The Jira project keys to scope the integration to."""
  project: String
}

"""Tuple for mapping Jira projects to Linear teams."""
type JiraLinearMapping {
  """The Jira id for this project."""
  jiraProjectId: String!

  """The Linear team id to map to the given project."""
  linearTeamId: String!
}

input JiraLinearMappingInput {
  """The Jira id for this project."""
  jiraProjectId: String!

  """The Linear team id to map to the given project."""
  linearTeamId: String!
}

"""Metadata about a Jira project."""
type JiraProjectData {
  """The Jira id for this project."""
  id: String!

  """The Jira key for this project, such as ENG."""
  key: String!

  """The Jira name for this project, such as Engineering."""
  name: String!
}

input JiraProjectDataInput {
  """The Jira id for this project."""
  id: String!

  """The Jira key for this project, such as ENG."""
  key: String!

  """The Jira name for this project, such as Engineering."""
  name: String!
}

"""Jira specific settings."""
type JiraSettings {
  """The mapping of Jira project id => Linear team id."""
  projectMapping: [JiraLinearMapping!]

  """The Jira projects for the organization."""
  projects: [JiraProjectData!]!
}

input JiraSettingsInput {
  """The mapping of Jira project id => Linear team id."""
  projectMapping: [JiraLinearMappingInput!]

  """The Jira projects for the organization."""
  projects: [JiraProjectDataInput!]!
}

input JoinOrganizationInput {
  """The identifier of the organization."""
  organizationId: String!
}

"""The `JSON` scalar type represents JSON values"""
scalar JSON

"""The `JSONObject` scalar type represents JSON values as a string"""
scalar JSONObject

"""A milestone that contains projects."""
type Milestone implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The name of the milestone."""
  name: String!

  """The organization that the milestone belongs to."""
  organization: Organization!

  """The sort order for the milestone."""
  sortOrder: Float!

  """Projects associated with the milestone."""
  projects(
    """[Alpha] Filter returned projects."""
    filter: ProjectFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectConnection!
}

type MilestoneConnection {
  edges: [MilestoneEdge!]!
  nodes: [Milestone!]!
  pageInfo: PageInfo!
}

input MilestoneCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The name of the milestone."""
  name: String!

  """The sort order of the milestone."""
  sortOrder: Float
}

type MilestoneEdge {
  node: Milestone!

  """Used in `before` and `after` args"""
  cursor: String!
}

"""[Alpha] Milestone filtering options."""
input MilestoneFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the milestone name."""
  name: StringComparator

  """Comparator for the milestone sort order."""
  sortOrder: NumberComparator

  """Filters that the milestones projects must satisfy."""
  projects: ProjectCollectionFilter

  """Compound filters, all of which need to be matched by the milestone."""
  and: [MilestoneFilter!]

  """Compound filters, one of which need to be matched by the milestone."""
  or: [MilestoneFilter!]
}

type MilestonePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The milesteone that was created or updated."""
  milestone: Milestone

  """Whether the operation was successful."""
  success: Boolean!
}

input MilestoneUpdateInput {
  """The name of the milestone."""
  name: String

  """The sort order of the milestone."""
  sortOrder: Float
}

type Mutation {
  """[Deprecated] Creates a new event."""
  eventCreate(
    """The event to create."""
    input: EventCreateInput!
  ): EventPayload!

  """[Internal] Creates a new API key."""
  apiKeyCreate(
    """The api key object to create."""
    input: ApiKeyCreateInput!
  ): ApiKeyPayload!

  """[Internal] Deletes an API key."""
  apiKeyDelete(
    """The identifier of the API key to delete."""
    id: String!
  ): ArchivePayload!

  """
  [Alpha] Creates a new attachment, or updates existing if the same `url` and `issueId` is used.
  """
  attachmentCreate(
    """The attachment object to create."""
    input: AttachmentCreateInput!
  ): AttachmentPayload!

  """[Alpha] Updates an existing issue attachment."""
  attachmentUpdate(
    """A partial attachment object to update the attachment with."""
    input: AttachmentUpdateInput!

    """The identifier of the attachment to update."""
    id: String!
  ): AttachmentPayload!

  """Link any url to an issue."""
  attachmentLinkURL(
    """The title to use for the attachment."""
    title: String

    """The issue for which to link the url."""
    issueId: String!

    """The url to link."""
    url: String!
  ): AttachmentPayload!

  """Link an existing Zendesk ticket to an issue."""
  attachmentLinkZendesk(
    """The issue for which to link the Zendesk ticket."""
    issueId: String!

    """The Zendesk ticket ID to link."""
    ticketId: String!
  ): AttachmentPayload!

  """Link an existing Discord message to an issue."""
  attachmentLinkDiscord(
    """The Discord message URL for the message to link."""
    url: String!

    """The Discord message ID for the message to link."""
    messageId: String!

    """The Discord channel ID for the message to link."""
    channelId: String!

    """The issue for which to link the Discord message."""
    issueId: String!
  ): AttachmentPayload!

  """Link an existing Front conversation to an issue."""
  attachmentLinkFront(
    """The issue for which to link the Front conversation."""
    issueId: String!

    """The Front conversation ID to link."""
    conversationId: String!
  ): FrontAttachmentPayload!

  """Link an existing Intercom conversation to an issue."""
  attachmentLinkIntercom(
    """The issue for which to link the Intercom conversation."""
    issueId: String!

    """The Intercom conversation ID to link."""
    conversationId: String!
  ): AttachmentPayload!

  """Link an existing Jira issue to an issue."""
  attachmentLinkJiraIssue(
    """The issue for which to link the Jira issue."""
    issueId: String!

    """The Jira issue key or ID to link."""
    jiraIssueId: String!
  ): AttachmentPayload!

  """[DEPRECATED] Archives an issue attachment."""
  attachmentArchive(
    """The identifier of the attachment to archive."""
    id: String!
  ): ArchivePayload! @deprecated(reason: "This mutation is deprecated, please use `attachmentDelete` instead")

  """[Alpha] Deletes an issue attachment."""
  attachmentDelete(
    """The identifier of the attachment to delete."""
    id: String!
  ): ArchivePayload!

  """
  Finds or creates a new user account by email and sends an email with token.
  """
  emailUserAccountAuthChallenge(
    """The data used for email authentication."""
    input: EmailUserAccountAuthChallengeInput!
  ): EmailUserAccountAuthChallengeResponse!

  """Authenticates a user account via email and authentication token."""
  emailTokenUserAccountAuth(
    """The data used for token authentication."""
    input: TokenUserAccountAuthInput!
  ): AuthResolverResponse!

  """
  Authenticates a user account via email and authentication token for SAML.
  """
  samlTokenUserAccountAuth(
    """The data used for token authentication."""
    input: TokenUserAccountAuthInput!
  ): AuthResolverResponse!

  """
  Authenticate user account through Google OAuth. This is the 2nd step of OAuth flow.
  """
  googleUserAccountAuth(
    """The data used for Google authentication."""
    input: GoogleUserAccountAuthInput!
  ): AuthResolverResponse!

  """Creates an organization from onboarding."""
  createOrganizationFromOnboarding(
    """Onboarding survey."""
    survey: OnboardingCustomerSurvey

    """Organization details for the new organization."""
    input: CreateOrganizationInput!
  ): CreateOrJoinOrganizationResponse!

  """Join an organization from onboarding."""
  joinOrganizationFromOnboarding(
    """Organization details for the organization to join."""
    input: JoinOrganizationInput!
  ): CreateOrJoinOrganizationResponse!

  """Leave an organization."""
  leaveOrganization(
    """ID of the organization to leave."""
    organizationId: String!
  ): CreateOrJoinOrganizationResponse!

  """Updates the billing email address for the customer."""
  billingEmailUpdate(
    """The properties of the billing details."""
    input: BillingEmailUpdateInput!
  ): BillingEmailPayload!

  """Update collaborative document with client steps."""
  collaborativeDocumentUpdate(input: CollaborationDocumentUpdateInput!): CollaborationDocumentUpdatePayload!

  """Creates a new comment."""
  commentCreate(
    """The comment object to create."""
    input: CommentCreateInput!
  ): CommentPayload!

  """Updates a comment."""
  commentUpdate(
    """A partial comment object to update the comment with."""
    input: CommentUpdateInput!

    """The identifier of the comment to update."""
    id: String!
  ): CommentPayload!

  """Deletes a comment."""
  commentDelete(
    """The identifier of the comment to delete."""
    id: String!
  ): ArchivePayload!

  """Saves user message."""
  contactCreate(
    """The contact entry to create."""
    input: ContactCreateInput!
  ): ContactPayload!

  """Creates a new custom view."""
  customViewCreate(
    """The properties of the custom view to create."""
    input: CustomViewCreateInput!
  ): CustomViewPayload!

  """Updates a custom view."""
  customViewUpdate(
    """The properties of the custom view to update."""
    input: CustomViewUpdateInput!

    """The identifier of the custom view to update."""
    id: String!
  ): CustomViewPayload!

  """Deletes a custom view."""
  customViewDelete(
    """The identifier of the custom view to delete."""
    id: String!
  ): ArchivePayload!

  """Creates a new cycle."""
  cycleCreate(
    """The cycle object to create."""
    input: CycleCreateInput!
  ): CyclePayload!

  """Updates a cycle."""
  cycleUpdate(
    """A partial cycle object to update the cycle with."""
    input: CycleUpdateInput!

    """The identifier of the cycle to update."""
    id: String!
  ): CyclePayload!

  """Archives a cycle."""
  cycleArchive(
    """The identifier of the cycle to archive."""
    id: String!
  ): ArchivePayload!

  """Always fails with internal error. Used to debug logging."""
  debugFailWithInternalError: DebugPayload!

  """
  [Internal] Always logs an error to Sentry as warning. Used to debug logging.
  """
  debugFailWithWarning: DebugPayload!

  """[Internal] Create the SAML test organization in development."""
  debugCreateSAMLOrg: DebugPayload!

  """[Internal] Create the OAuth test applications in development."""
  debugCreateOAuthApps: DebugPayload!

  """[Internal] Create test subscription in development."""
  debugCreateSubscription(
    """Subscription type."""
    subscriptionType: String!
  ): DebugPayload!

  """Creates a new document."""
  documentCreate(
    """The document to create."""
    input: DocumentCreateInput!
  ): DocumentPayload!

  """Updates a document."""
  documentUpdate(
    """A partial document object to update the document with."""
    input: DocumentUpdateInput!

    """
    The identifier of the document to update. Also the identifier from the URL is accepted.
    """
    id: String!
  ): DocumentPayload!

  """Deletes a document."""
  documentDelete(
    """The identifier of the document to delete."""
    id: String!
  ): ArchivePayload!

  """Subscribes the email to the newsletter."""
  emailSubscribe(
    """Subscription details."""
    input: EmailSubscribeInput!
  ): EmailSubscribePayload!

  """Unsubscribes the user from one type of emails."""
  emailUnsubscribe(
    """Unsubscription details."""
    input: EmailUnsubscribeInput!
  ): EmailUnsubscribePayload!

  """Creates a custom emoji."""
  emojiCreate(
    """The emoji object to create."""
    input: EmojiCreateInput!
  ): EmojiPayload!

  """Deletes an emoji."""
  emojiDelete(
    """The identifier of the emoji to delete."""
    id: String!
  ): ArchivePayload!

  """Creates a new favorite (project, cycle etc)."""
  favoriteCreate(
    """The favorite object to create."""
    input: FavoriteCreateInput!
  ): FavoritePayload!

  """Updates a favorite."""
  favoriteUpdate(
    """A partial favorite object to update the favorite with."""
    input: FavoriteUpdateInput!

    """The identifier of the favorite to update."""
    id: String!
  ): FavoritePayload!

  """Deletes a favorite reference."""
  favoriteDelete(
    """The identifier of the favorite reference to delete."""
    id: String!
  ): ArchivePayload!

  """Saves user feedback."""
  feedbackCreate(
    """The feedback entry to create."""
    input: FeedbackCreateInput!
  ): FeedbackPayload!

  """
  XHR request payload to upload an images, video and other attachments directly to Linear's cloud storage.
  """
  fileUpload(
    """Optional metadata."""
    metaData: JSON

    """Should the file be made publicly accessible (default: false)."""
    makePublic: Boolean

    """File size of the uploaded file."""
    size: Int!

    """MIME type of the uploaded file."""
    contentType: String!

    """Filename of the uploaded file."""
    filename: String!
  ): UploadPayload!

  """Upload an image from an URL to Linear."""
  imageUploadFromUrl(
    """URL of the file to be uploaded to Linear."""
    url: String!
  ): ImageUploadFromUrlPayload!

  """[INTERNAL] Updates the integration."""
  integrationSettingsUpdate(
    """An integration settings object."""
    input: IntegrationSettingsInput!

    """The identifier of the integration to update."""
    id: String!
  ): IntegrationPayload!

  """Generates a webhook for the GitHub commit integration."""
  integrationGithubCommitCreate: GitHubCommitIntegrationPayload!

  """Connects the organization with the GitHub App."""
  integrationGithubConnect(
    """The GitHub data to connect with."""
    installationId: String!
  ): IntegrationPayload!

  """Connects the organization with a GitLab Access Token."""
  integrationGitlabConnect(
    """The URL of the GitLab installation"""
    gitlabUrl: String!

    """The GitLab Access Token to connect with."""
    accessToken: String!
  ): IntegrationPayload!

  """
  [INTERNAL] Connects the organization with a Jira Personal Access Token.
  """
  jiraIntegrationConnect(
    """Jira integration settings."""
    input: JiraConfigurationInput!
  ): IntegrationPayload!

  """Integrates the organization with Intercom."""
  integrationIntercom(
    """The Intercom OAuth redirect URI."""
    redirectUri: String!

    """The Intercom OAuth code."""
    code: String!
  ): IntegrationPayload!

  """Disconnects the organization from Intercom."""
  integrationIntercomDelete: IntegrationPayload!

  """[DEPRECATED] Updates settings on the Intercom integration."""
  integrationIntercomSettingsUpdate(
    """
    A partial Intercom integration settings object to update the integration settings with.
    """
    input: IntercomSettingsInput!
  ): IntegrationPayload! @deprecated(reason: "This mutation is deprecated, please use `integrationSettingsUpdate` instead")

  """Integrates the organization with Discord."""
  integrationDiscord(
    """The Discord OAuth redirect URI."""
    redirectUri: String!

    """The Discord OAuth code."""
    code: String!
  ): IntegrationPayload!

  """Integrates the organization with Slack."""
  integrationSlack(
    """
    [DEPRECATED] Whether or not v2 of Slack OAuth should be used. No longer used.
    """
    shouldUseV2Auth: Boolean

    """The Slack OAuth redirect URI."""
    redirectUri: String!

    """The Slack OAuth code."""
    code: String!
  ): IntegrationPayload!

  """Integrates your personal notifications with Slack."""
  integrationSlackPersonal(
    """The Slack OAuth redirect URI."""
    redirectUri: String!

    """The Slack OAuth code."""
    code: String!
  ): IntegrationPayload!

  """Slack webhook integration."""
  integrationSlackPost(
    """
    [DEPRECATED] Whether or not v2 of Slack OAuth should be used. No longer used.
    """
    shouldUseV2Auth: Boolean

    """The Slack OAuth redirect URI."""
    redirectUri: String!

    """Integration's associated team."""
    teamId: String!

    """The Slack OAuth code."""
    code: String!
  ): IntegrationPayload!

  """Slack integration for project notifications."""
  integrationSlackProjectPost(
    """The Slack OAuth redirect URI."""
    redirectUri: String!

    """Integration's associated project."""
    projectId: String!

    """The Slack OAuth code."""
    code: String!
  ): IntegrationPayload!

  """Imports custom emojis from your Slack workspace."""
  integrationSlackImportEmojis(
    """The Slack OAuth redirect URI."""
    redirectUri: String!

    """The Slack OAuth code."""
    code: String!
  ): IntegrationPayload!

  """Integrates the organization with Figma."""
  integrationFigma(
    """The Figma OAuth redirect URI."""
    redirectUri: String!

    """The Figma OAuth code."""
    code: String!
  ): IntegrationPayload!

  """Integrates the organization with Google Sheets."""
  integrationGoogleSheets(
    """The Google OAuth code."""
    code: String!
  ): IntegrationPayload!

  """Manually update Google Sheets data."""
  refreshGoogleSheetsData(
    """The identifier of the Google Sheets integration to update."""
    id: String!
  ): IntegrationPayload!

  """Integrates the organization with Sentry."""
  integrationSentryConnect(
    """The slug of the Sentry organization being connected."""
    organizationSlug: String!

    """The Sentry grant code that's exchanged for OAuth tokens."""
    code: String!

    """The Sentry installationId to connect with."""
    installationId: String!
  ): IntegrationPayload!

  """Integrates the organization with Front."""
  integrationFront(
    """The Front OAuth redirect URI."""
    redirectUri: String!

    """The Front OAuth code."""
    code: String!
  ): IntegrationPayload!

  """Integrates the organization with Zendesk."""
  integrationZendesk(
    """The Zendesk OAuth redirect URI."""
    redirectUri: String!

    """The Zendesk OAuth scopes."""
    scope: String!

    """The Zendesk OAuth code."""
    code: String!

    """The Zendesk installation subdomain."""
    subdomain: String!
  ): IntegrationPayload!

  """Enables Loom integration for the organization."""
  integrationLoom: IntegrationPayload! @deprecated(reason: "Not available.")

  """Deletes an integration."""
  integrationDelete(
    """The identifier of the integration to delete."""
    id: String!
  ): ArchivePayload!

  """Archives an integration resource."""
  integrationResourceArchive(
    """The identifier of the integration resource to archive."""
    id: String!
  ): ArchivePayload!

  """Kicks off a GitHub import job."""
  issueImportCreateGithub(
    """ID of issue import. If not provided it will be generated."""
    id: String

    """Whether or not we should collect the data for closed issues."""
    includeClosedIssues: Boolean

    """
    Whether to instantly process the import with the default configuration mapping.
    """
    instantProcess: Boolean

    """Whether or not we should import GitHub organization level projects."""
    githubShouldImportOrgProjects: Boolean

    """
    GitHub owner (user or org) for the repository from which we will import data.
    """
    githubRepoOwner: String!

    """GitHub repository name from which we will import data."""
    githubRepoName: String!

    """GitHub token to fetch information from the GitHub API."""
    githubToken: String!

    """ID of the team into which to import data."""
    teamId: String!
  ): IssueImportPayload!

  """Kicks off a Jira import job."""
  issueImportCreateJira(
    """ID of issue import. If not provided it will be generated."""
    id: String

    """Whether or not we should collect the data for closed issues."""
    includeClosedIssues: Boolean

    """
    Whether to instantly process the import with the default configuration mapping.
    """
    instantProcess: Boolean

    """Jira installation or cloud hostname."""
    jiraHostname: String!

    """Jira user account email."""
    jiraEmail: String!

    """Jira project key from which we will import data."""
    jiraProject: String!

    """Jira personal access token to access Jira REST API."""
    jiraToken: String!

    """ID of the team into which to import data."""
    teamId: String!
  ): IssueImportPayload!

  """Kicks off a Clubhouse import job."""
  issueImportCreateClubhouse(
    """ID of issue import. If not provided it will be generated."""
    id: String

    """Whether or not we should collect the data for closed issues."""
    includeClosedIssues: Boolean

    """
    Whether to instantly process the import with the default configuration mapping.
    """
    instantProcess: Boolean

    """Clubhouse team name to choose which issues we should import."""
    clubhouseTeamName: String!

    """Clubhouse token to fetch information from the Clubhouse API."""
    clubhouseToken: String!

    """ID of the team into which to import data."""
    teamId: String!
  ): IssueImportPayload!

  """Kicks off an Asana import job."""
  issueImportCreateAsana(
    """ID of issue import. If not provided it will be generated."""
    id: String

    """Whether or not we should collect the data for closed issues."""
    includeClosedIssues: Boolean

    """
    Whether to instantly process the import with the default configuration mapping.
    """
    instantProcess: Boolean

    """Asana team name to choose which issues we should import."""
    asanaTeamName: String!

    """Asana token to fetch information from the Asana API."""
    asanaToken: String!

    """ID of the team into which to import data."""
    teamId: String!
  ): IssueImportPayload!

  """Deletes an import job."""
  issueImportDelete(
    """ID of the issue import to delete."""
    issueImportId: String!
  ): IssueImportDeletePayload!

  """Kicks off import processing."""
  issueImportProcess(
    """The mapping configuration to use for processing the import."""
    mapping: JSONObject!

    """ID of the issue import which we're going to process."""
    issueImportId: String!
  ): IssueImportPayload!

  """Updates the mapping for the issue import."""
  issueImportUpdate(
    """The properties of the issue import to update."""
    input: IssueImportUpdateInput!

    """The identifier of the issue import."""
    id: String!
  ): IssueImportPayload!

  """Creates a new label."""
  issueLabelCreate(
    """
    Whether to replace all team-specific labels with the same name with this newly created workspace label.
    """
    replaceTeamLabels: Boolean

    """The issue label to create."""
    input: IssueLabelCreateInput!
  ): IssueLabelPayload!

  """Updates an label."""
  issueLabelUpdate(
    """A partial label object to update."""
    input: IssueLabelUpdateInput!

    """The identifier of the label to update."""
    id: String!
  ): IssueLabelPayload!

  """Archives an issue label."""
  issueLabelArchive(
    """The identifier of the label to archive."""
    id: String!
  ): ArchivePayload! @deprecated(reason: "Labels are deleted instead of archived.")

  """Deletes an issue label."""
  issueLabelDelete(
    """The identifier of the label to delete."""
    id: String!
  ): ArchivePayload!

  """Creates a new issue relation."""
  issueRelationCreate(
    """The issue relation to create."""
    input: IssueRelationCreateInput!
  ): IssueRelationPayload!

  """Updates an issue relation."""
  issueRelationUpdate(
    """The properties of the issue relation to update."""
    input: IssueRelationUpdateInput!

    """The identifier of the issue relation to update."""
    id: String!
  ): IssueRelationPayload!

  """Deletes an issue relation."""
  issueRelationDelete(
    """The identifier of the issue relation to delete."""
    id: String!
  ): ArchivePayload!

  """Creates a new issue."""
  issueCreate(
    """The issue object to create."""
    input: IssueCreateInput!
  ): IssuePayload!

  """Updates an issue."""
  issueUpdate(
    """A partial issue object to update the issue with."""
    input: IssueUpdateInput!

    """The identifier of the issue to update."""
    id: String!
  ): IssuePayload!

  """Updates multiple issues at once."""
  issueBatchUpdate(
    """A partial issue object to update the issues with."""
    input: IssueUpdateInput!

    """The id's of the issues to update. Can't be more than 50 at a time."""
    ids: [UUID!]!
  ): IssueBatchPayload!

  """Archives an issue."""
  issueArchive(
    """Whether to trash the issue"""
    trash: Boolean

    """The identifier of the issue to archive."""
    id: String!
  ): ArchivePayload!

  """Unarchives an issue."""
  issueUnarchive(
    """The identifier of the issue to archive."""
    id: String!
  ): ArchivePayload!

  """Deletes (trashes) an issue."""
  issueDelete(
    """The identifier of the issue to delete."""
    id: String!
  ): ArchivePayload!

  """Creates a new milestone."""
  milestoneCreate(
    """The issue object to create."""
    input: MilestoneCreateInput!
  ): MilestonePayload!

  """Updates a milestone."""
  milestoneUpdate(
    """A partial milestone object to update the milestone with."""
    input: MilestoneUpdateInput!

    """The identifier of the milestone to update."""
    id: String!
  ): MilestonePayload!

  """Deletes a milestone."""
  milestoneDelete(
    """The identifier of the milestone to delete."""
    id: String!
  ): ArchivePayload!

  """Creates a notification."""
  notificationCreate(
    """A partial notification object to update the issue with."""
    input: NotificationUpdateInput!

    """The identifier of the notification to update."""
    id: String!
  ): NotificationPayload!

  """Updates a notification."""
  notificationUpdate(
    """A partial notification object to update the issue with."""
    input: NotificationUpdateInput!

    """The identifier of the notification to update."""
    id: String!
  ): NotificationPayload!

  """Archives a notification."""
  notificationArchive(
    """The id of the notification to archive."""
    id: String!
  ): ArchivePayload!

  """Unarchives a notification."""
  notificationUnarchive(
    """The id of the notification to archive."""
    id: String!
  ): ArchivePayload!

  """Creates a new notification subscription for a team or a project."""
  notificationSubscriptionCreate(
    """The subscription object to create."""
    input: NotificationSubscriptionCreateInput!
  ): NotificationSubscriptionPayload!

  """Deletes a notification subscription reference."""
  notificationSubscriptionDelete(
    """The identifier of the notification subscription reference to delete."""
    id: String!
  ): ArchivePayload!

  """
  [Internal] Creates a temporary authentication code that can be exchanged for an OAuth token.
  """
  oauthAuthStringChallenge(
    """The group of scopes that are being requested."""
    scope: [String!]!

    """The identifier of the OAuth client that's trying to authenticate."""
    appId: String!
  ): OauthAuthStringChallengePayload!

  """[Internal] Authenticates an auth string by the user."""
  oauthAuthStringAuthorize(
    """The auth string to authenticate."""
    authString: String!

    """The identifier of the OAuth client that's trying to authenticate."""
    appId: String!
  ): OauthAuthStringAuthorizePayload!

  """
  [Internal] Returns an access token once the auth string has been authenticated.
  """
  oauthAuthStringCheck(
    """The auth string to authenticate."""
    authString: String!

    """The identifier of the OAuth client that's trying to authenticate."""
    appId: String!
  ): OauthAuthStringCheckPayload!

  """Creates a new OAuth client."""
  oauthClientCreate(
    """The OAuth client application object to create."""
    input: OauthClientCreateInput!
  ): OauthClientPayload!

  """Updates an OAuth client."""
  oauthClientUpdate(
    """A partial client object to update the OAuth client with."""
    input: OauthClientUpdateInput!

    """The identifier of the OAuth client to update."""
    id: String!
  ): OauthClientPayload!

  """Archives an OAuth client."""
  oauthClientArchive(
    """The identifier of the OAuth client to archive."""
    id: String!
  ): ArchivePayload!

  """Updates an OAuth client."""
  oauthClientRotateSecret(
    """
    The identifier of the OAuth client for which we want to rotate the secret.
    """
    id: String!
  ): RotateSecretPayload!

  """Revokes an OAuth token."""
  oauthTokenRevoke(
    """The group of scopes for the tokens to be revoked."""
    scope: [String!]!

    """The identifier of the OAuth client for the tokens to be revoked."""
    appId: String!
  ): OauthTokenRevokePayload!

  """Verifies a domain to be added to an organization."""
  organizationDomainVerify(
    """The organization domain to verify."""
    input: OrganizationDomainVerificationInput!
  ): OrganizationDomainPayload!

  """Adds a domain to be allowed for an organization."""
  organizationDomainCreate(
    """The organization domain entry to create."""
    input: OrganizationDomainCreateInput!
  ): OrganizationDomainPayload!

  """Deletes a domain."""
  organizationDomainDelete(
    """The identifier of the domain to delete."""
    id: String!
  ): ArchivePayload!

  """Creates a new organization invite."""
  organizationInviteCreate(
    """The organization invite object to create."""
    input: OrganizationInviteCreateInput!
  ): OrganizationInvitePayload!

  """Re-send an organization invite."""
  resendOrganizationInvite(
    """The identifier of the organization invite to be re-send."""
    id: String!
  ): ArchivePayload!

  """Deletes an organization invite."""
  organizationInviteDelete(
    """The identifier of the organization invite to delete."""
    id: String!
  ): ArchivePayload!

  """Updates the user's organization."""
  organizationUpdate(
    """A partial organization object to update the organization with."""
    input: UpdateOrganizationInput!
  ): OrganizationPayload!

  """
  Get an organization's delete confirmation token. Administrator privileges required.
  """
  organizationDeleteChallenge: OrganizationDeletePayload!

  """Delete's an organization. Administrator privileges required."""
  organizationDelete(
    """Information required to delete an organization."""
    input: DeleteOrganizationInput!
  ): OrganizationDeletePayload!

  """
  Cancels the deletion of an organization. Administrator privileges required.
  """
  organizationCancelDelete: OrganizationCancelDeletePayload!

  """Creates a new project link."""
  projectLinkCreate(
    """The project link object to create."""
    input: ProjectLinkCreateInput!
  ): ProjectLinkPayload!

  """Updates a project link."""
  projectLinkUpdate(
    """The project link object to update."""
    input: ProjectLinkUpdateInput!

    """The identifier of the project link to update."""
    id: String!
  ): ProjectLinkPayload!

  """Deletes a project link."""
  projectLinkDelete(
    """The identifier of the project link to delete."""
    id: String!
  ): ArchivePayload!

  """Creates a new project."""
  projectCreate(
    """The issue object to create."""
    input: ProjectCreateInput!
  ): ProjectPayload!

  """Updates a project."""
  projectUpdate(
    """A partial project object to update the project with."""
    input: ProjectUpdateInput!

    """
    The identifier of the project to update. Also the identifier from the URL is accepted.
    """
    id: String!
  ): ProjectPayload!

  """
  Deletes a project. All issues will be disassociated from the deleted project.
  """
  projectDelete(
    """
    The identifier of the project to delete. Also the identifier from the URL is accepted.
    """
    id: String!
  ): ArchivePayload!

  """Archives a project."""
  projectArchive(
    """
    The identifier of the project to archive. Also the identifier from the URL is accepted.
    """
    id: String!
  ): ArchivePayload! @deprecated(reason: "Deprecated in favor of projectDelete.")

  """Unarchives a project."""
  projectUnarchive(
    """
    The identifier of the project to restore. Also the identifier from the URL is accepted.
    """
    id: String!
  ): ArchivePayload!

  """Creates a push subscription."""
  pushSubscriptionCreate(
    """The push subscription to create."""
    input: PushSubscriptionCreateInput!
  ): PushSubscriptionPayload!

  """Deletes a push subscription."""
  pushSubscriptionDelete(
    """The identifier of the push subscription to delete."""
    id: String!
  ): PushSubscriptionPayload!

  """Creates a new reaction."""
  reactionCreate(
    """The reaction object to create."""
    input: ReactionCreateInput!
  ): ReactionPayload!

  """Deletes a reaction."""
  reactionDelete(
    """The identifier of the reaction to delete."""
    id: String!
  ): ArchivePayload!

  """Create CSV export report for the organization."""
  createCsvExportReport(includePrivateTeamIds: [String!]): CreateCsvExportReportPayload!

  """
  [Internal] Creates a subscription session. Used internally to integrate with Stripe.
  """
  subscriptionSessionCreate(
    """The id of an optional coupon to apply."""
    coupon: String

    """The name of the plan."""
    plan: String!
  ): SubscriptionSessionPayload!

  """
  [Internal] Creates a subscription update session. Used internally to integrate with Stripe.
  """
  subscriptionUpdateSessionCreate: SubscriptionSessionPayload!

  """[Internal] Updates a subscription."""
  subscriptionUpdate(
    """The properties of the subscription."""
    input: SubscriptionUpdateInput!

    """The identifier of the subscription."""
    id: String!
  ): SubscriptionPayload!

  """[Internal] Upgrades a subscription plan."""
  subscriptionUpgrade(
    """The subscription type to upgrade to."""
    type: String!

    """The identifier of the subscription."""
    id: String!
  ): SubscriptionPayload!

  """[Internal] Archives a subscription."""
  subscriptionArchive(
    """The identifier of the subscription to archive."""
    id: String!
  ): ArchivePayload!

  """Deletes a previously used team key."""
  teamKeyDelete(
    """The identifier of the team key to delete."""
    id: String!
  ): ArchivePayload!

  """Creates a new team membership."""
  teamMembershipCreate(
    """The team membership object to create."""
    input: TeamMembershipCreateInput!
  ): TeamMembershipPayload!

  """Updates a team membership."""
  teamMembershipUpdate(
    """A partial team membership object to update the team membership with."""
    input: TeamMembershipUpdateInput!

    """The identifier of the team membership to update."""
    id: String!
  ): TeamMembershipPayload!

  """Deletes a team membership."""
  teamMembershipDelete(
    """The identifier of the team membership to delete."""
    id: String!
  ): ArchivePayload!

  """
  Creates a new team. The user who creates the team will automatically be added as a member to the newly created team.
  """
  teamCreate(
    """The team id to copy settings from."""
    copySettingsFromTeamId: String

    """The team object to create."""
    input: TeamCreateInput!
  ): TeamPayload!

  """Updates a team."""
  teamUpdate(
    """A partial team object to update the team with."""
    input: TeamUpdateInput!

    """The identifier of the team to update."""
    id: String!
  ): TeamPayload!

  """Deletes a team."""
  teamDelete(
    """The identifier of the team to delete."""
    id: String!
  ): ArchivePayload!

  """Creates a new template."""
  templateCreate(
    """The template object to create."""
    input: TemplateCreateInput!
  ): TemplatePayload!

  """Updates an existing template."""
  templateUpdate(
    """The properties of the template to update."""
    input: TemplateUpdateInput!

    """The identifier of the template."""
    id: String!
  ): TemplatePayload!

  """Deletes a template."""
  templateDelete(
    """The identifier of the template to delete."""
    id: String!
  ): ArchivePayload!

  """
  Updates a user. Only available to organization admins and the user themselves.
  """
  userUpdate(
    """A partial user object to update the user with."""
    input: UpdateUserInput!

    """
    The identifier of the user to update. Use `me` to reference currently authenticated user.
    """
    id: String!
  ): UserPayload!

  """Connects the Discord user to this Linear account via OAuth2."""
  userDiscordConnect(
    """The Discord OAuth redirect URI."""
    redirectUri: String!

    """The Discord OAuth code."""
    code: String!
  ): UserPayload!

  """Disconnects the external user from this Linear account."""
  userExternalUserDisconnect(
    """The external service to disconnect"""
    service: String!
  ): UserPayload!

  """Makes user an admin. Can only be called by an admin."""
  userPromoteAdmin(
    """The identifier of the user to make an admin."""
    id: String!
  ): UserAdminPayload!

  """Makes user a regular user. Can only be called by an admin."""
  userDemoteAdmin(
    """The identifier of the user to make a regular user."""
    id: String!
  ): UserAdminPayload!

  """Suspends a user. Can only be called by an admin."""
  userSuspend(
    """The identifier of the user to suspend."""
    id: String!
  ): UserAdminPayload!

  """Un-suspends a user. Can only be called by an admin."""
  userUnsuspend(
    """The identifier of the user to unsuspend."""
    id: String!
  ): UserAdminPayload!

  """Updates the user's settings."""
  userSettingsUpdate(
    """A partial notification object to update the settings with."""
    input: UserSettingsUpdateInput!

    """The identifier of the userSettings to update."""
    id: String!
  ): UserSettingsPayload!

  """[Deprecated] Updates a user's settings flag."""
  userSettingsFlagIncrement(
    """Flag to increment."""
    flag: String!
  ): UserSettingsFlagPayload!

  """Resets user's setting flags."""
  userSettingsFlagsReset(
    """The flags to reset. If not provided all flags will be reset."""
    flags: [UserFlagType!]
  ): UserSettingsFlagsResetPayload!

  """Updates a user's settings flag."""
  userFlagUpdate(
    """Flag operation to perform"""
    operation: UserFlagUpdateOperation!

    """Settings flag to increment."""
    flag: UserFlagType!
  ): UserSettingsFlagPayload!

  """Subscribes user to changelog newsletter."""
  userSubscribeToNewsletter: UserSubscribeToNewsletterPayload!

  """Creates a new ViewPreferences object."""
  viewPreferencesCreate(
    """The ViewPreferences object to create."""
    input: ViewPreferencesCreateInput!
  ): ViewPreferencesPayload!

  """Updates an existing ViewPreferences object."""
  viewPreferencesUpdate(
    """The properties of the view preferences."""
    input: ViewPreferencesUpdateInput!

    """The identifier of the ViewPreferences object."""
    id: String!
  ): ViewPreferencesPayload!

  """Deletes a ViewPreferences."""
  viewPreferencesDelete(
    """The identifier of the ViewPreferences to delete."""
    id: String!
  ): ArchivePayload!

  """Creates a new webhook."""
  webhookCreate(
    """The webhook object to create."""
    input: WebhookCreateInput!
  ): WebhookPayload!

  """Updates an existing Webhook."""
  webhookUpdate(
    """The properties of the Webhook."""
    input: WebhookUpdateInput!

    """The identifier of the Webhook."""
    id: String!
  ): WebhookPayload!

  """Deletes a Webhook."""
  webhookDelete(
    """The identifier of the Webhook to delete."""
    id: String!
  ): ArchivePayload!

  """Creates a new state, adding it to the workflow of a team."""
  workflowStateCreate(
    """The state to create."""
    input: WorkflowStateCreateInput!
  ): WorkflowStatePayload!

  """Updates a state."""
  workflowStateUpdate(
    """A partial state object to update."""
    input: WorkflowStateUpdateInput!

    """The identifier of the state to update."""
    id: String!
  ): WorkflowStatePayload!

  """
  Archives a state. Only states with issues that have all been archived can be archived.
  """
  workflowStateArchive(
    """The identifier of the state to archive."""
    id: String!
  ): ArchivePayload!
}

"""Comparator for strings."""
input NestedStringComparator {
  """Equals constraint."""
  eq: String

  """Not-equals constraint."""
  neq: String

  """In-array constraint."""
  in: [String!]

  """Not-in-array constraint."""
  nin: [String!]

  """
  Equals case insensitive. Matches any values that matches the given string case insensitive.
  """
  eqIgnoreCase: String

  """
  Not-equals case insensitive. Matches any values that don't match the given string case insensitive.
  """
  neqIgnoreCase: String

  """
  Starts with constraint. Matches any values that start with the given string.
  """
  startsWith: String

  """
  Doesn't start with constraint. Matches any values that don't start with the given string.
  """
  notStartsWith: String

  """
  Ends with constraint. Matches any values that end with the given string.
  """
  endsWith: String

  """
  Doesn't end with constraint. Matches any values that don't end with the given string.
  """
  notEndsWith: String

  """Contains constraint. Matches any values that contain the given string."""
  contains: String

  """
  Contains case insensitive constraint. Matches any values that contain the given string case insensitive.
  """
  containsIgnoreCase: String

  """
  Doesn't contain constraint. Matches any values that don't contain the given string.
  """
  notContains: String

  """
  Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive.
  """
  notContainsIgnoreCase: String
}

interface Node {
  """The unique identifier of the entity."""
  id: ID!
}

"""A notification sent to a user."""
interface Notification {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """Notification type"""
  type: String!

  """The user that received the notification."""
  user: User!

  """
  The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  """
  readAt: DateTime

  """
  The time at when an email reminder for this notification was sent to the user. Null, if no email
      reminder has been sent.
  """
  emailedAt: DateTime

  """
  The time until a notification will be snoozed. After that it will appear in the inbox again.
  """
  snoozedUntilAt: DateTime
}

type NotificationConnection {
  edges: [NotificationEdge!]!
  nodes: [Notification!]!
  pageInfo: PageInfo!
}

type NotificationEdge {
  node: Notification!

  """Used in `before` and `after` args"""
  cursor: String!
}

type NotificationPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The notification that was created or updated."""
  notification: Notification!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Notification subscriptions for models."""
type NotificationSubscription implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The type of the subscription."""
  type: String!

  """The user associated with notification subscriptions."""
  user: User!

  """Subscribed team."""
  team: Team

  """Subscribed project."""
  project: Project
}

type NotificationSubscriptionConnection {
  edges: [NotificationSubscriptionEdge!]!
  nodes: [NotificationSubscription!]!
  pageInfo: PageInfo!
}

input NotificationSubscriptionCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The identifier of the team to subscribe to."""
  teamId: String

  """The identifier of the project to subscribe to."""
  projectId: String
}

type NotificationSubscriptionEdge {
  node: NotificationSubscription!

  """Used in `before` and `after` args"""
  cursor: String!
}

type NotificationSubscriptionPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The notification subscription that was created or updated."""
  notificationSubscription: NotificationSubscription!

  """Whether the operation was successful."""
  success: Boolean!
}

input NotificationUpdateInput {
  """The time when notification was marked as read."""
  readAt: DateTime

  """
  The time until a notification will be snoozed. After that it will appear in the inbox again.
  """
  snoozedUntilAt: DateTime
}

"""[Alpha] Cycle filtering options."""
input NullableCycleFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the cycle number."""
  number: NumberComparator

  """Comparator for the cycle name."""
  name: StringComparator

  """Comparator for the cycle start date."""
  startsAt: DateComparator

  """Comparator for the cycle ends at date."""
  endsAt: DateComparator

  """Comparator for the cycle completed at date."""
  completedAt: DateComparator

  """Filters that the cycles team must satisfy."""
  team: TeamFilter

  """Filters that the cycles issues must satisfy."""
  issues: IssueCollectionFilter

  """Compound filters, all of which need to be matched by the cycle."""
  and: [CycleFilter!]

  """Compound filters, one of which need to be matched by the cycle."""
  or: [CycleFilter!]

  """Filter based on the existence of the relation."""
  null: Boolean
}

"""Comparator for optional dates."""
input NullableDateComparator {
  """Equals constraint."""
  eq: DateTime

  """Not-equals constraint."""
  neq: DateTime

  """In-array constraint."""
  in: [DateTime!]

  """Not-in-array constraint."""
  nin: [DateTime!]

  """
  Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
  """
  null: Boolean

  """
  Less-than constraint. Matches any values that are less than the given value.
  """
  lt: DateTime

  """
  Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
  """
  lte: DateTime

  """
  Greater-than constraint. Matches any values that are greater than the given value.
  """
  gt: DateTime

  """
  Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
  """
  gte: DateTime
}

"""[Alpha] User filtering options."""
input NullableMilestoneFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the milestone name."""
  name: StringComparator

  """Comparator for the milestone sort order."""
  sortOrder: NumberComparator

  """Filters that the milestones projects must satisfy."""
  projects: ProjectCollectionFilter

  """Compound filters, all of which need to be matched by the milestone."""
  and: [MilestoneFilter!]

  """Compound filters, one of which need to be matched by the milestone."""
  or: [MilestoneFilter!]

  """Filter based on the existence of the relation."""
  null: Boolean
}

"""Comparator for optional numbers."""
input NullableNumberComparator {
  """Equals constraint."""
  eq: Float

  """Not-equals constraint."""
  neq: Float

  """In-array constraint."""
  in: [Float!]

  """Not-in-array constraint."""
  nin: [Float!]

  """
  Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
  """
  null: Boolean

  """
  Less-than constraint. Matches any values that are less than the given value.
  """
  lt: Float

  """
  Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
  """
  lte: Float

  """
  Greater-than constraint. Matches any values that are greater than the given value.
  """
  gt: Float

  """
  Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
  """
  gte: Float
}

"""[Alpha] Project filtering options."""
input NullableProjectFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the project name."""
  name: StringComparator

  """Comparator for the project state."""
  state: StringComparator

  """Comparator for the project start date."""
  startDate: NullableDateComparator

  """Comparator for the project target date."""
  targetDate: NullableDateComparator

  """Filters that the projects creator must satisfy."""
  creator: UserFilter

  """Filters that the projects lead must satisfy."""
  lead: NullableUserFilter

  """Filters that the projects members must satisfy."""
  members: UserFilter

  """Filters that the projects milestones must satisfy."""
  milestone: NullableMilestoneFilter

  """Filters that the projects issues must satisfy."""
  issues: IssueCollectionFilter

  """Compound filters, all of which need to be matched by the project."""
  and: [ProjectFilter!]

  """Compound filters, one of which need to be matched by the project."""
  or: [ProjectFilter!]

  """Filter based on the existence of the relation."""
  null: Boolean
}

"""Comparator for optional strings."""
input NullableStringComparator {
  """Equals constraint."""
  eq: String

  """Not-equals constraint."""
  neq: String

  """In-array constraint."""
  in: [String!]

  """Not-in-array constraint."""
  nin: [String!]

  """
  Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
  """
  null: Boolean

  """
  Equals case insensitive. Matches any values that matches the given string case insensitive.
  """
  eqIgnoreCase: String

  """
  Not-equals case insensitive. Matches any values that don't match the given string case insensitive.
  """
  neqIgnoreCase: String

  """
  Starts with constraint. Matches any values that start with the given string.
  """
  startsWith: String

  """
  Doesn't start with constraint. Matches any values that don't start with the given string.
  """
  notStartsWith: String

  """
  Ends with constraint. Matches any values that end with the given string.
  """
  endsWith: String

  """
  Doesn't end with constraint. Matches any values that don't end with the given string.
  """
  notEndsWith: String

  """Contains constraint. Matches any values that contain the given string."""
  contains: String

  """
  Contains case insensitive constraint. Matches any values that contain the given string case insensitive.
  """
  containsIgnoreCase: String

  """
  Doesn't contain constraint. Matches any values that don't contain the given string.
  """
  notContains: String

  """
  Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive.
  """
  notContainsIgnoreCase: String
}

input NullableTimelessDateComparator {
  """Equals constraint."""
  eq: TimelessDate

  """Not-equals constraint."""
  neq: TimelessDate

  """In-array constraint."""
  in: [TimelessDate!]

  """Not-in-array constraint."""
  nin: [TimelessDate!]

  """
  Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
  """
  null: Boolean

  """
  Less-than constraint. Matches any values that are less than the given value.
  """
  lt: TimelessDate

  """
  Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
  """
  lte: TimelessDate

  """
  Greater-than constraint. Matches any values that are greater than the given value.
  """
  gt: TimelessDate

  """
  Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
  """
  gte: TimelessDate
}

"""[Alpha] User filtering options."""
input NullableUserFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the user's name."""
  name: StringComparator

  """Comparator for the user's display name."""
  displayName: StringComparator

  """Comparator for the user's email."""
  email: StringComparator

  """Comparator for the user's activity status."""
  active: BooleanComparator

  """Filters that the users assigned issues must satisfy."""
  assignedIssues: IssueCollectionFilter

  """Compound filters, all of which need to be matched by the user."""
  and: [UserFilter!]

  """Compound filters, one of which need to be matched by the user."""
  or: [UserFilter!]

  """Comparator for the user's admin status."""
  admin: BooleanComparator

  """
  Filter based on the currently authenticated user. Set to true to filter for
  the authenticated user, false for any other user.
  """
  isMe: BooleanComparator

  """Filter based on the existence of the relation."""
  null: Boolean
}

"""Comparator for numbers."""
input NumberComparator {
  """Equals constraint."""
  eq: Float

  """Not-equals constraint."""
  neq: Float

  """In-array constraint."""
  in: [Float!]

  """Not-in-array constraint."""
  nin: [Float!]

  """
  Less-than constraint. Matches any values that are less than the given value.
  """
  lt: Float

  """
  Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
  """
  lte: Float

  """
  Greater-than constraint. Matches any values that are greater than the given value.
  """
  gt: Float

  """
  Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
  """
  gte: Float
}

type OauthAuthStringAuthorizePayload {
  """Whether the operation was successful."""
  success: Boolean!
}

type OauthAuthStringChallengePayload {
  """Whether the operation was successful."""
  success: Boolean!

  """The created authentication string."""
  authString: String!
}

type OauthAuthStringCheckPayload {
  """Whether the operation was successful."""
  success: Boolean!

  """Access token for use."""
  token: String
}

"""OAuth2 client application"""
type OauthClient implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """OAuth application's client ID."""
  clientId: String!

  """OAuth application's client name."""
  name: String!

  """Information about the application."""
  description: String!

  """Name of the developer."""
  developer: String!

  """Url of the developer."""
  developerUrl: String!

  """Image of the application."""
  imageUrl: String!

  """OAuth application's client secret."""
  clientSecret: String!

  """List of allowed redirect URIs for the application."""
  redirectUris: [String!]!

  """
  Whether the OAuth application is publicly visible, or only visible to the creating workspace.
  """
  publicEnabled: Boolean!

  """The resource types to request when creating new webhooks."""
  webhookResourceTypes: [String!]!

  """Webhook URL"""
  webhookUrl: String
}

input OauthClientCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The application's name."""
  name: String!

  """User facing description of the application."""
  description: String

  """Name of the developer of the application."""
  developer: String!

  """Url of the developer (homepage or docs)."""
  developerUrl: String!

  """List of allowed redirect URIs for the application."""
  redirectUris: [String!]!

  """URL for the app icon."""
  imageUrl: String

  """
  Whether the OAuth application should be publicly visible, or only visible to the creating workspace.
  """
  publicEnabled: Boolean

  """The URL that will be called on data changes."""
  webhookUrl: String

  """List of resources the webhooks should subscribe to."""
  webhookResourceTypes: [String!]!
}

type OauthClientPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The OAuth client application that was created or updated."""
  oauthClient: OauthClient!

  """Whether the operation was successful."""
  success: Boolean!
}

input OauthClientUpdateInput {
  """The application's name."""
  name: String

  """User facing description of the application."""
  description: String

  """Name of the developer of the application."""
  developer: String

  """URL of the developer (homepage or docs)."""
  developerUrl: String

  """List of allowed redirect URIs for the application."""
  redirectUris: [String!]

  """URL for the app icon."""
  imageUrl: String

  """
  Whether the OAuth application should be publicly visible, or only visible to the creating workspace.
  """
  publicEnabled: Boolean

  """The URL that will be called on data changes."""
  webhookUrl: String

  """List of resources the webhooks should subscribe to."""
  webhookResourceTypes: [String!]
}

type OauthTokenRevokePayload {
  """Whether the operation was successful."""
  success: Boolean!
}

input OnboardingCustomerSurvey {
  companyRole: String
  companySize: String
}

"""
An organization. Organizations are root-level objects that contain user accounts and teams.
"""
type Organization implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The organization's name."""
  name: String!

  """The organization's unique URL key."""
  urlKey: String!

  """The organization's logo URL."""
  logoUrl: String

  """Rolling 30-day total upload volume for the organization, in megabytes."""
  periodUploadVolume: Float!

  """
  How git branches are formatted. If null, default formatting will be used.
  """
  gitBranchFormat: String

  """
  Whether the Git integration linkback messages should be sent to private repositories.
  """
  gitLinkbackMessagesEnabled: Boolean!

  """
  Whether the Git integration linkback messages should be sent to public repositories.
  """
  gitPublicLinkbackMessagesEnabled: Boolean!

  """Whether the organization is using a roadmap."""
  roadmapEnabled: Boolean!

  """Whether SAML authentication is enabled for organization."""
  samlEnabled: Boolean!

  """Allowed authentication providers, empty array means all are allowed"""
  allowedAuthServices: [String!]!

  """The time at which deletion of the organization was requested."""
  deletionRequestedAt: DateTime

  """Users associated with the organization."""
  users(
    """Should query return disabled/suspended users (default: false)."""
    includeDisabled: Boolean

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): UserConnection!

  """Teams associated with the organization."""
  teams(
    """[Alpha] Filter returned teams."""
    filter: TeamFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TeamConnection!

  """Milestones associated with the organization."""
  milestones(
    """[Alpha] Filter returned projects."""
    filter: MilestoneFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): MilestoneConnection!

  """Integrations associated with the organization."""
  integrations(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IntegrationConnection!

  """The organization's subscription to a paid plan."""
  subscription: Subscription

  """Number of active users in the organization."""
  userCount: Int!

  """Number of issues in the organization."""
  createdIssueCount: Int!

  """Templates associated with the organization."""
  templates(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TemplateConnection!

  """Labels associated with the organization."""
  labels(
    """[Alpha] Filter returned issue labels."""
    filter: IssueLabelFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueLabelConnection!
}

type OrganizationCancelDeletePayload {
  """Whether the operation was successful."""
  success: Boolean!
}

type OrganizationDeletePayload {
  """Whether the operation was successful."""
  success: Boolean!
}

"""Defines the use of a domain by an organization."""
type OrganizationDomain implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """Domain name"""
  name: String!

  """Is this domain verified"""
  verified: Boolean!

  """The user who added the domain."""
  creator: User

  """E-mail used to verify this domain"""
  verificationEmail: String
}

input OrganizationDomainCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The domain name to add."""
  name: String!

  """The email address to which to send the verification code."""
  verificationEmail: String!
}

type OrganizationDomainPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The organization domain that was created or updated."""
  organizationDomain: OrganizationDomain!

  """Whether the operation was successful."""
  success: Boolean!
}

type OrganizationDomainSimplePayload {
  """Whether the operation was successful."""
  success: Boolean!
}

input OrganizationDomainVerificationInput {
  """The identifier of the domain being verified."""
  organizationDomainId: String!

  """The verification code sent via email."""
  verificationCode: String!
}

type OrganizationExistsPayload {
  """Whether the operation was successful."""
  success: Boolean!

  """Whether the organization exists."""
  exists: Boolean!
}

"""An invitation to the organization that has been sent via email."""
type OrganizationInvite implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The invitees email address."""
  email: String!

  """The permission that the invitee will receive upon accepting invite."""
  role: UserRoleType!

  """The permission that the invitee will receive upon accepting invite."""
  permission: String

  """The invite was sent to external address."""
  external: Boolean!

  """
  The time at which the invite was accepted. Null, if the invite hasn't been accepted
  """
  acceptedAt: DateTime

  """
  The time at which the invite will be expiring. Null, if the invite shouldn't expire
  """
  expiresAt: DateTime

  """The user who created the invitation."""
  inviter: User!

  """
  The user who has accepted the invite. Null, if the invite hasn't been accepted.
  """
  invitee: User

  """The organization that the invite is associated with."""
  organization: Organization!
}

type OrganizationInviteConnection {
  edges: [OrganizationInviteEdge!]!
  nodes: [OrganizationInvite!]!
  pageInfo: PageInfo!
}

input OrganizationInviteCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The email of the invitee."""
  email: String!

  """Whether the invite should grant admin permissions."""
  permission: String

  """The message to send to the invitee."""
  message: String

  """The teams that the user has been invited to."""
  teamIds: [String!]
}

type OrganizationInviteDetailsPayload {
  """The name of the inviter"""
  inviter: String!

  """The email of the invitee"""
  email: String!

  """Whether the invite should grant admin permissions"""
  permission: String

  """When the invite was created."""
  createdAt: DateTime!

  """Name of the workspace the invite is for."""
  organizationName: String!

  """ID of the workspace the invite is for."""
  organizationId: String!

  """URL of the workspace logo the invite is for."""
  organizationLogoUrl: String

  """Whether the invite has already been accepted."""
  accepted: Boolean!

  """Whether the invite has expired."""
  expired: Boolean!
}

type OrganizationInviteEdge {
  node: OrganizationInvite!

  """Used in `before` and `after` args"""
  cursor: String!
}

type OrganizationInvitePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The organization invite that was created or updated."""
  organizationInvite: OrganizationInvite!

  """Whether the operation was successful."""
  success: Boolean!
}

type OrganizationPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The organization that was created or updated."""
  organization: Organization

  """Whether the operation was successful."""
  success: Boolean!
}

type PageInfo {
  """Indicates if there are more results when paginating backward."""
  hasPreviousPage: Boolean!

  """Indicates if there are more results when paginating forward."""
  hasNextPage: Boolean!

  """Cursor representing the first result in the paginated results."""
  startCursor: String

  """Cursor representing the last result in the paginated results."""
  endCursor: String
}

"""By which field should the pagination order by"""
enum PaginationOrderBy {
  createdAt
  updatedAt
}

"""A project."""
type Project implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The project's name."""
  name: String!

  """The project's description."""
  description: String!

  """The project's unique URL slug."""
  slugId: String!

  """The icon of the project."""
  icon: String

  """The project's color."""
  color: String!

  """The type of the state."""
  state: String!

  """The user who created the project."""
  creator: User!

  """The project lead."""
  lead: User

  """The milestone that this project is associated with."""
  milestone: Milestone

  """[Internal] The estimated start date of the project."""
  startDate: TimelessDate

  """The estimated completion date of the project."""
  targetDate: TimelessDate

  """The time at which the project was moved into started state."""
  startedAt: DateTime

  """The time at which the project was moved into completed state."""
  completedAt: DateTime

  """The time at which the project was moved into canceled state."""
  canceledAt: DateTime

  """
  The time at which the project was automatically archived by the auto pruning process.
  """
  autoArchivedAt: DateTime

  """The sort order for the project within its milestone."""
  sortOrder: Float!

  """The total number of issues in the project after each week."""
  issueCountHistory: [Float!]!

  """The number of completed issues in the project after each week."""
  completedIssueCountHistory: [Float!]!

  """The total number of estimation points after each week."""
  scopeHistory: [Float!]!

  """The number of completed estimation points after each week."""
  completedScopeHistory: [Float!]!

  """Whether to send new issue notifications to Slack."""
  slackNewIssue: Boolean!

  """Whether to send new issue comment notifications to Slack."""
  slackIssueComments: Boolean!

  """Whether to send new issue status updates to Slack."""
  slackIssueStatuses: Boolean!

  """Project URL."""
  url: String!

  """Teams associated with this project."""
  teams(
    """[Alpha] Filter returned teams."""
    filter: TeamFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TeamConnection!

  """Users that are members of the project."""
  members(
    """[Alpha] Filter returned users."""
    filter: UserFilter

    """Should query return disabled/suspended users (default: false)."""
    includeDisabled: Boolean

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): UserConnection!

  """Project updates associated with the project."""
  projectUpdates(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectUpdateConnection!

  """Documents associated with the project."""
  documents(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): DocumentConnection!

  """Issues associated with the project."""
  issues(
    """[Alpha] Filter returned issues."""
    filter: IssueFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """Links associated with the project."""
  links(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectLinkConnection!

  """
  The overall progress of the project. This is the (completed estimate points +
  0.25 * in progress estimate points) / total estimate points.
  """
  progress: Float!
}

"""[Alpha] Project filtering options."""
input ProjectCollectionFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the project name."""
  name: StringComparator

  """Comparator for the project state."""
  state: StringComparator

  """Comparator for the project start date."""
  startDate: NullableDateComparator

  """Comparator for the project target date."""
  targetDate: NullableDateComparator

  """Filters that the projects creator must satisfy."""
  creator: UserFilter

  """Filters that the projects lead must satisfy."""
  lead: NullableUserFilter

  """Filters that the projects members must satisfy."""
  members: UserFilter

  """Filters that the projects milestones must satisfy."""
  milestone: NullableMilestoneFilter

  """Filters that the projects issues must satisfy."""
  issues: IssueCollectionFilter

  """Compound filters, all of which need to be matched by the project."""
  and: [ProjectFilter!]

  """Compound filters, one of which need to be matched by the project."""
  or: [ProjectFilter!]

  """Filters that needs to be matched by some projects."""
  some: ProjectFilter

  """Filters that needs to be matched by all projects."""
  every: ProjectFilter
}

type ProjectConnection {
  edges: [ProjectEdge!]!
  nodes: [Project!]!
  pageInfo: PageInfo!
}

input ProjectCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The name of the project."""
  name: String!

  """The icon of the project."""
  icon: String

  """The color of the project."""
  color: String

  """The state of the project."""
  state: String

  """The description for the project."""
  description: String

  """The identifier of the milestone to associate the project with."""
  milestoneId: String

  """The identifiers of the teams this project is associated with."""
  teamIds: [String!]!

  """The identifier of the project lead."""
  leadId: String

  """The identifiers of the members of this project."""
  memberIds: [String!]

  """[Internal] The planned start date of the project."""
  startDate: TimelessDate

  """The planned target date of the project."""
  targetDate: TimelessDate

  """The sort order for the project within its milestone."""
  sortOrder: Float
}

type ProjectEdge {
  node: Project!

  """Used in `before` and `after` args"""
  cursor: String!
}

"""[Alpha] Project filtering options."""
input ProjectFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the project name."""
  name: StringComparator

  """Comparator for the project state."""
  state: StringComparator

  """Comparator for the project start date."""
  startDate: NullableDateComparator

  """Comparator for the project target date."""
  targetDate: NullableDateComparator

  """Filters that the projects creator must satisfy."""
  creator: UserFilter

  """Filters that the projects lead must satisfy."""
  lead: NullableUserFilter

  """Filters that the projects members must satisfy."""
  members: UserFilter

  """Filters that the projects milestones must satisfy."""
  milestone: NullableMilestoneFilter

  """Filters that the projects issues must satisfy."""
  issues: IssueCollectionFilter

  """Compound filters, all of which need to be matched by the project."""
  and: [ProjectFilter!]

  """Compound filters, one of which need to be matched by the project."""
  or: [ProjectFilter!]
}

"""An external link for a project."""
type ProjectLink implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The link's URL."""
  url: String!

  """The link's label."""
  label: String!

  """The user who created the link."""
  creator: User!

  """The project that the link is associated with."""
  project: Project!
}

type ProjectLinkConnection {
  edges: [ProjectLinkEdge!]!
  nodes: [ProjectLink!]!
  pageInfo: PageInfo!
}

input ProjectLinkCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The URL of the link."""
  url: String!

  """The label for the link."""
  label: String!

  """Related project for the link."""
  projectId: String!
}

type ProjectLinkEdge {
  node: ProjectLink!

  """Used in `before` and `after` args"""
  cursor: String!
}

type ProjectLinkPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The project that was created or updated."""
  projectLink: ProjectLink!

  """Whether the operation was successful."""
  success: Boolean!
}

input ProjectLinkUpdateInput {
  """The URL of the link."""
  url: String

  """The label for the link."""
  label: String
}

"""A project related notification"""
type ProjectNotification implements Notification & Entity & Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """Notification type"""
  type: String!

  """The user that received the notification."""
  user: User!

  """
  The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  """
  readAt: DateTime

  """
  The time at when an email reminder for this notification was sent to the user. Null, if no email
      reminder has been sent.
  """
  emailedAt: DateTime

  """
  The time until a notification will be snoozed. After that it will appear in the inbox again.
  """
  snoozedUntilAt: DateTime

  """The project related to the notification."""
  project: Project!

  """The project update related to the notification."""
  projectUpdate: ProjectUpdate
}

type ProjectPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The project that was created or updated."""
  project: Project

  """Whether the operation was successful."""
  success: Boolean!
}

"""A update associated with an project."""
type ProjectUpdate implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The update content in markdown format."""
  body: String!

  """The project that the update is associated with."""
  project: Project!

  """The user who wrote the update."""
  user: User!

  """The time the project update was edited."""
  editedAt: DateTime
}

type ProjectUpdateConnection {
  edges: [ProjectUpdateEdge!]!
  nodes: [ProjectUpdate!]!
  pageInfo: PageInfo!
}

type ProjectUpdateEdge {
  node: ProjectUpdate!

  """Used in `before` and `after` args"""
  cursor: String!
}

input ProjectUpdateInput {
  """The state of the project."""
  state: String

  """The name of the project."""
  name: String

  """The description for the project."""
  description: String

  """The identifier of the milestone to associate the project with."""
  milestoneId: String

  """The icon of the project."""
  icon: String

  """The color of the project."""
  color: String

  """The identifiers of the teams this project is associated with."""
  teamIds: [String!]

  """The identifier of the project lead."""
  leadId: String

  """The identifiers of the members of this project."""
  memberIds: [String!]

  """[Internal] The planned start date of the project."""
  startDate: TimelessDate

  """The planned target date of the project."""
  targetDate: TimelessDate

  """The date when the project was completed."""
  completedAt: DateTime

  """The date when the project was canceled."""
  canceledAt: DateTime

  """Whether to send new issue notifications to Slack."""
  slackNewIssue: Boolean

  """Whether to send new issue comment notifications to Slack."""
  slackIssueComments: Boolean

  """Whether to send issue status update notifications to Slack."""
  slackIssueStatuses: Boolean

  """The sort order for the project within its milestone."""
  sortOrder: Float
}

"""Pull request data"""
type PullRequestPayload {
  status: String!
  number: Float!
  url: String!
  draft: Boolean!
  id: String!
  title: String!
  branch: String!
  userId: String!
  userLogin: String!
  repoLogin: String!
  repoName: String!
  createdAt: String!
  updatedAt: String!
  closedAt: String!
  mergedAt: String!
}

"""A user's web browser push notification subscription."""
type PushSubscription implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime
}

type PushSubscriptionConnection {
  edges: [PushSubscriptionEdge!]!
  nodes: [PushSubscription!]!
  pageInfo: PageInfo!
}

input PushSubscriptionCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The user identifier of the subscription."""
  userId: String!

  """The data of the subscription in stringified JSON format."""
  data: String!
}

type PushSubscriptionEdge {
  node: PushSubscription!

  """Used in `before` and `after` args"""
  cursor: String!
}

type PushSubscriptionPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type PushSubscriptionTestPayload {
  """Whether the operation was successful."""
  success: Boolean!
}

type Query {
  """
  [Internal] Fetch data to catch up the client to the state of the world.
  """
  syncBootstrap(
    """If defined, only models of the given type will be loaded."""
    onlyModels: [String!]

    """If defined, only models for the given sync groups will be loaded."""
    syncGroups: [String!]
  ): SyncResponse!

  """[Internal] Fetches delta sync packets."""
  syncDelta(
    """After which update to start, used for pagination."""
    offset: Int

    """Up until which sync id to load data for."""
    toSyncId: Int!

    """The last sync id the client has seen."""
    lastSyncId: Int!
  ): SyncDeltaResponse!

  """[Internal] Syncs a batch of models."""
  syncBatch(
    """The requests to load."""
    requests: [BatchRequest!]!
  ): SyncBatchResponse!

  """[Internal] Fetches the dependencies of a model."""
  dependentModelSync(
    """
    Whether to also include the dependent model referenced by the given identifier in the response.
    """
    includeDependent: Boolean

    """The identifier of the model whose dependencies to load."""
    identifier: String!

    """The class name of the model to load."""
    modelClass: String!
  ): DependencyResponse!

  """[Internal] Fetches an archived model."""
  archivedModelSync(
    """
    The identifier of the model to load. What an identifier is specific to the model class.
    """
    identifier: String!

    """The class name of the model to load."""
    modelClass: String!
  ): ArchiveResponse!

  """[Internal] Fetches archived models."""
  archivedModelsSync(
    """The class name of the models to load."""
    modelClass: String!

    """The teamId for which to load archived models."""
    teamId: String!

    """
    How trashed issues should be loaded. Defaults to TrashOptionType.excludeTrash
    """
    trashOption: TrashOptionType

    """Retrieve issues that have been archived before this date."""
    before: DateTime

    """The number of issues to load."""
    last: Int
  ): ArchiveResponse!

  """[Internal] All API keys for the user."""
  apiKeys(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ApiKeyConnection!

  """Get basic information for an application."""
  applicationInfo(
    """The client ID of the application."""
    clientId: String!
  ): Application!

  """
  Get information for an application and whether a user has approved it for the given scopes.
  """
  applicationWithAuthorization(
    """Actor mode used for the authorization."""
    actor: String = "user"

    """Redirect URI for the application."""
    redirectUri: String

    """Scopes being requested by the application"""
    scope: [String!]!

    """The client ID of the application."""
    clientId: String!
  ): UserAuthorizedApplication!

  """Get all authorized applications for a user"""
  authorizedApplications: [AuthorizedApplication!]!

  """
  [Alpha] All issue attachments.
  
  To get attachments for a given URL, use `attachmentsForURL` query.
  """
  attachments(
    """[Alpha] Filter returned attachments."""
    filter: AttachmentFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): AttachmentConnection!

  """
  
  [Alpha] One specific issue attachment.
  [Deprecated] 'url' can no longer be used as the 'id' parameter. Use 'attachmentsForUrl' instead
  """
  attachment(id: String!): Attachment!

  """[Alpha] Returns issue attachments for a given `url`."""
  attachmentsForURL(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """The attachment URL."""
    url: String!
  ): AttachmentConnection!

  """
  
  [Alpha] Query an issue by its associated attachment, and its id.
  
  """
  attachmentIssue(
    """
    `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
    """
    id: String!
  ): Issue! @deprecated(reason: "Will be removed in near future, please use `attachmentsForURL` to get attachments and their issues instead.")

  """List of audit entry types."""
  auditEntryTypes: [AuditEntryType!]!

  """All audit log entries."""
  auditEntries(
    """[Alpha] Filter returned audit entries."""
    filter: AuditEntryFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): AuditEntryConnection!

  """Fetch users belonging to this user account."""
  availableUsers: AuthResolverResponse!

  """Fetch SSO login URL for the email provided."""
  ssoUrlFromEmail(
    """Whether the client is the desktop app."""
    isDesktop: Boolean

    """Email to query the SSO login URL by."""
    email: String!
  ): SsoUrlFromEmailResponse!

  """Billing details for the customer."""
  billingDetails: BillingDetailsPayload!

  """Join collaborative document and get missing steps."""
  collaborativeDocumentJoin(
    """The identifier of the client."""
    clientId: String!

    """The identifier of the Issue to join."""
    issueId: String!

    """Document version."""
    version: Int!
  ): CollaborationDocumentUpdatePayload!

  """All comments."""
  comments(
    """[Alpha] Filter returned comments."""
    filter: CommentFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CommentConnection!

  """A specific comment."""
  comment(
    """The identifier of the comment to retrieve."""
    id: String!
  ): Comment!

  """Custom views for the user."""
  customViews(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CustomViewConnection!

  """One specific custom view."""
  customView(id: String!): CustomView!

  """All cycles."""
  cycles(
    """[Alpha] Filter returned users."""
    filter: CycleFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CycleConnection!

  """One specific cycle."""
  cycle(id: String!): Cycle!

  """All documents for the project."""
  documents(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): DocumentConnection!

  """One specific document."""
  document(id: String!): Document!

  """All custom emojis."""
  emojis(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): EmojiConnection!

  """A specific emoji."""
  emoji(
    """The identifier of the emoji to retrieve."""
    id: String!
  ): Emoji!

  """The user's favorites."""
  favorites(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): FavoriteConnection!

  """One specific favorite."""
  favorite(id: String!): Favorite!

  """
  Fetch Figma screenshot and other information with file and node identifiers.
  """
  figmaEmbedInfo(
    """Figma node identifier."""
    nodeId: String

    """Figma file identifier."""
    fileId: String!
  ): FigmaEmbedPayload!

  """All integrations."""
  integrations(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IntegrationConnection!

  """One specific integration."""
  integration(id: String!): Integration!

  """
  All integrations resources (e.g. linked GitHub pull requests for issues).
  """
  integrationResources(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IntegrationResourceConnection!

  """
  One specific integration resource. (e.g. linked GitHub pull requests for an issue)
  """
  integrationResource(id: String!): IntegrationResource!

  """Fetches the GitHub token, completing the OAuth flow."""
  issueImportFinishGithubOAuth(
    """OAuth code."""
    code: String!
  ): GithubOAuthTokenPayload!

  """All issue labels."""
  issueLabels(
    """[Alpha] Filter returned issue labels."""
    filter: IssueLabelFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueLabelConnection!

  """One specific label."""
  issueLabel(id: String!): IssueLabel!

  """All issue relationships."""
  issueRelations(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueRelationConnection!

  """One specific issue relation."""
  issueRelation(id: String!): IssueRelation!

  """All issues."""
  issues(
    """[Alpha] Filter returned issues."""
    filter: IssueFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """One specific issue."""
  issue(id: String!): Issue!

  """
  [ALPHA] Search issues. This query is experimental and is subject to change without notice.
  """
  issueSearch(
    """[Alpha] Filter returned issues."""
    filter: IssueFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """[Deprecated] Search string to look for."""
    query: String!
  ): IssueConnection!

  """[Internal] Find issue based on the VCS branch name."""
  issueVcsBranchSearch(
    """The VCS branch name to search for."""
    branchName: String!
  ): Issue

  """Issue priority values and corresponding labels."""
  issuePriorityValues: [IssuePriorityValue!]!

  """All milestones."""
  milestones(
    """[Alpha] Filter returned projects."""
    filter: MilestoneFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): MilestoneConnection!

  """One specific milestone."""
  milestone(id: String!): Milestone!

  """All notifications."""
  notifications(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): NotificationConnection!

  """One specific notification."""
  notification(id: String!): Notification!

  """The user's notification subscriptions."""
  notificationSubscriptions(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): NotificationSubscriptionConnection!

  """One specific notification subscription."""
  notificationSubscription(id: String!): NotificationSubscription!

  """All invites for the organization."""
  organizationInvites(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): OrganizationInviteConnection!

  """One specific organization invite."""
  organizationInvite(id: String!): OrganizationInvite!

  """One specific organization invite."""
  organizationInviteDetails(id: String!): OrganizationInviteDetailsPayload!

  """The user's organization."""
  organization: Organization!

  """Does the organization exist."""
  organizationExists(urlKey: String!): OrganizationExistsPayload!

  """All links for the project."""
  projectLinks(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectLinkConnection!

  """One specific project link."""
  projectLink(id: String!): ProjectLink!

  """All projects."""
  projects(
    """[Alpha] Filter returned projects."""
    filter: ProjectFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectConnection!

  """One specific project."""
  project(id: String!): Project!

  """Sends a test push message."""
  pushSubscriptionTest: PushSubscriptionTestPayload!

  """The status of the rate limiter."""
  rateLimitStatus: RateLimitPayload!

  """All comment emoji reactions."""
  reactions(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ReactionConnection!

  """A specific reaction."""
  reaction(
    """The identifier to retrieve."""
    id: String!
  ): Reaction!

  """The organization's subscription."""
  subscription: Subscription

  """All team memberships."""
  teamMemberships(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TeamMembershipConnection!

  """One specific team membership."""
  teamMembership(id: String!): TeamMembership!

  """
  All teams whose issues can be accessed by the user. This might be different
  from `administrableTeams`, which also includes teams whose settings can be
  changed by the user.
  """
  teams(
    """[Alpha] Filter returned teams."""
    filter: TeamFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TeamConnection!

  """
  All teams you the user can administrate. Administrable teams are teams whose
  settings the user can change, but to whose issues the user doesn't necessarily
  have access to.
  """
  administrableTeams(
    """[Alpha] Filter returned teams."""
    filter: TeamFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TeamConnection!

  """One specific team."""
  team(id: String!): Team!

  """All templates from all users."""
  templates: [Template!]!

  """A specific template."""
  template(
    """The identifier of the template to retrieve."""
    id: String!
  ): Template!

  """All users for the organization."""
  users(
    """[Alpha] Filter returned users."""
    filter: UserFilter

    """Should query return disabled/suspended users (default: false)."""
    includeDisabled: Boolean

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): UserConnection!

  """One specific user."""
  user(
    """
    The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
    """
    id: String!
  ): User!

  """The currently authenticated user."""
  viewer: User!

  """The user's settings."""
  userSettings: UserSettings!

  """All webhooks."""
  webhooks(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): WebhookConnection!

  """A specific webhook."""
  webhook(
    """The identifier of the webhook to retrieve."""
    id: String!
  ): Webhook!

  """All issue workflow states."""
  workflowStates(
    """[Alpha] Filter returned workflow states."""
    filter: WorkflowStateFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): WorkflowStateConnection!

  """One specific state."""
  workflowState(id: String!): WorkflowState!
}

type RateLimitPayload {
  """The identifier we rate limit on."""
  identifier: String

  """The kind of rate limit selected for this request."""
  kind: String!

  """The state of the rate limit."""
  limits: [RateLimitResultPayload!]!
}

type RateLimitResultPayload {
  """What is being rate limited."""
  type: String!

  """The requested quantity for this type of limit."""
  requestedAmount: Float!

  """The total allowed quantity for this type of limit."""
  allowedAmount: Float!

  """The period in which the rate limit is fully replenished in ms."""
  period: Float!

  """The remaining quantity for this type of limit after this request."""
  remainingAmount: Float!

  """
  The timestamp after the rate limit is fully replenished as a UNIX timestamp.
  """
  reset: Float!
}

"""A reaction associated with a comment."""
type Reaction implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """Name of the reaction's emoji."""
  emoji: String!

  """The user who reacted."""
  user: User!

  """The comment that the reaction is associated with."""
  comment: Comment!
}

type ReactionConnection {
  edges: [ReactionEdge!]!
  nodes: [Reaction!]!
  pageInfo: PageInfo!
}

input ReactionCreateInput {
  """The identifier. If none is provided, the backend will generate one"""
  id: String

  """The emoji the user reacted with."""
  emoji: String

  """The comment to associate the reaction with."""
  commentId: String!
}

type ReactionEdge {
  node: Reaction!

  """Used in `before` and `after` args"""
  cursor: String!
}

type ReactionPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!
  reaction: Reaction!
  success: Boolean!
}

type RotateSecretPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type SamlConfiguration {
  """Sign in endpoint URL for the identity provider."""
  ssoEndpoint: String

  """
  Binding method for authentication call. Can be either `post` (default) or `redirect`.
  """
  ssoBinding: String

  """
  The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`.
  """
  ssoSignAlgo: String

  """List of allowed email domains for SAML authentication."""
  allowedDomains: [String!]

  """The issuer's custom entity ID."""
  issuerEntityId: String

  """X.509 Signing Certificate in string form."""
  ssoSigningCert: String
}

input SamlConfigurationInput {
  """X.509 Signing Certificate in string form."""
  ssoSigningCert: String

  """Sign in endpoint URL for the identity provider."""
  ssoEndpoint: String

  """
  Binding method for authentication call. Can be either `post` (default) or `redirect`.
  """
  ssoBinding: String

  """
  The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`.
  """
  ssoSignAlgo: String

  """List of allowed email domains for SAML authentication."""
  allowedDomains: [String!]

  """The issuer's custom entity ID."""
  issuerEntityId: String
}

"""The organization's SAML configuration"""
type SamlConfigurationPayload {
  """Sign in endpoint URL for the identity provider."""
  ssoEndpoint: String

  """
  Binding method for authentication call. Can be either `post` (default) or `redirect`.
  """
  ssoBinding: String

  """
  The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`.
  """
  ssoSignAlgo: String

  """List of allowed email domains for SAML authentication."""
  allowedDomains: [String!]

  """The issuer's custom entity ID."""
  issuerEntityId: String
}

"""Sentry issue data"""
type SentryIssuePayload {
  """The Sentry identifier for the issue."""
  issueId: String!

  """The description of the issue."""
  webUrl: String!

  """The type of the actor who created the issue."""
  actorType: String!

  """The Sentry identifier of the actor who created the issue."""
  actorId: Float!

  """The name of the Sentry actor who created this issue."""
  actorName: String!

  """The Sentry identifier of the project this issue belongs to."""
  projectId: Float!

  """The slug of the project this issue belongs to."""
  projectSlug: String!

  """The title of the issue."""
  issueTitle: String!

  """The shortId of the issue."""
  shortId: String!

  """The date this issue was first seen."""
  firstSeen: String!

  """
  The name of the first release version this issue appeared on, if available.
  """
  firstVersion: String
}

"""Sentry specific settings."""
type SentrySettings {
  """The slug of the Sentry organization being connected."""
  organizationSlug: String!
}

input SentrySettingsInput {
  """The slug of the Sentry organization being connected."""
  organizationSlug: String!
}

"""Slack notification specific settings."""
type SlackPostSettings {
  channel: String!
  channelId: String!
  configurationUrl: String!
}

input SlackPostSettingsInput {
  channel: String!
  channelId: String!
  configurationUrl: String!
}

type SsoUrlFromEmailResponse {
  """Whether the operation was successful."""
  success: Boolean!

  """SAML SSO sign-in URL."""
  samlSsoUrl: String!
}

type StepsResponse {
  """Client's document version."""
  version: Int!

  """New document steps from the client."""
  steps: [JSON!]

  """List of client IDs for the document steps."""
  clientIds: [String!]!
}

"""Comparator for strings."""
input StringComparator {
  """Equals constraint."""
  eq: String

  """Not-equals constraint."""
  neq: String

  """In-array constraint."""
  in: [String!]

  """Not-in-array constraint."""
  nin: [String!]

  """
  Equals case insensitive. Matches any values that matches the given string case insensitive.
  """
  eqIgnoreCase: String

  """
  Not-equals case insensitive. Matches any values that don't match the given string case insensitive.
  """
  neqIgnoreCase: String

  """
  Starts with constraint. Matches any values that start with the given string.
  """
  startsWith: String

  """
  Doesn't start with constraint. Matches any values that don't start with the given string.
  """
  notStartsWith: String

  """
  Ends with constraint. Matches any values that end with the given string.
  """
  endsWith: String

  """
  Doesn't end with constraint. Matches any values that don't end with the given string.
  """
  notEndsWith: String

  """Contains constraint. Matches any values that contain the given string."""
  contains: String

  """
  Contains case insensitive constraint. Matches any values that contain the given string case insensitive.
  """
  containsIgnoreCase: String

  """
  Doesn't contain constraint. Matches any values that don't contain the given string.
  """
  notContains: String

  """
  Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive.
  """
  notContainsIgnoreCase: String
}

"""The subscription of an organization."""
type Subscription implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The subscription type."""
  type: String!

  """The number of seats in the subscription."""
  seats: Float!

  """The creator of the subscription."""
  creator: User

  """The organization that the subscription is associated with."""
  organization: Organization!

  """The date the subscription was canceled, if any."""
  canceledAt: DateTime

  """The subscription type of a pending change. Null if no change pending."""
  pendingChangeType: String

  """The date the subscription will be billed next."""
  nextBillingAt: DateTime
}

type SubscriptionPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The subscription entity being mutated."""
  subscription: Subscription!

  """
  The date the subscription was set to cancel at the end of the billing period, if any.
  """
  canceledAt: DateTime

  """Whether the operation was successful."""
  success: Boolean!
}

type SubscriptionSessionPayload {
  """The subscription session that was created or updated."""
  session: String
}

input SubscriptionUpdateInput {
  """The date the subscription was set to cancel, if any."""
  canceledAt: DateTime

  """The subscription type of a pending change. Null if no change pending."""
  pendingChangeType: String
}

"""Contains the requested relations."""
type SyncBatchResponse {
  """A JSON serialized collection of relations model object."""
  models: String!
}

"""Contains a delta sync."""
type SyncDeltaResponse {
  """A JSON serialized collection of delta packets."""
  updates: String

  """Whether the client should try loading more."""
  loadMore: Boolean!

  """
  Whether loading the delta was successful. In case it wasn't, the client is instructed to do a full bootstrap.
  """
  success: Boolean!
}

type SynchronizedPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!
}

"""
Contains either the full serialized state of the application or delta packets that the requester can 
  apply to the local data set in order to be up-to-date.
"""
type SyncResponse {
  """
  The full state of the organization as a serialized JSON object.
      Mutually exclusive with the delta property
  """
  state: String

  """
  JSON serialized delta changes that the client can apply to its local state 
      in order to catch up with the state of the world.
  """
  delta: String

  """The sync groups that the user is subscribed to."""
  subscribedSyncGroups: [String!]!

  """The last sync id covered by the response."""
  lastSyncId: Float!

  """
  The version of the remote database. Incremented by 1 for each migration run on the database.
  """
  databaseVersion: Float!
}

"""An organizational unit that contains issues."""
type Team implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The team's name."""
  name: String!

  """The team's unique key. The key is used in URLs."""
  key: String!

  """The team's description."""
  description: String

  """The icon of the team."""
  icon: String

  """The team's color."""
  color: String

  """The organization that the team is associated with."""
  organization: Organization!

  """Whether the team uses cycles."""
  cyclesEnabled: Boolean!

  """The day of the week that a new cycle starts."""
  cycleStartDay: Float!

  """The duration of a cycle in weeks."""
  cycleDuration: Float!

  """The cooldown time after each cycle in weeks."""
  cycleCooldownTime: Float!

  """Auto assign started issues to current cycle."""
  cycleIssueAutoAssignStarted: Boolean!

  """Auto assign completed issues to current cycle."""
  cycleIssueAutoAssignCompleted: Boolean!

  """Only allow issues issues with cycles in Active Issues."""
  cycleLockToActive: Boolean!

  """How many upcoming cycles to create."""
  upcomingCycleCount: Float!

  """
  The timezone of the team. Defaults to "America/Los_Angeles"
  """
  timezone: String!

  """Unique hash for the team to be used in invite URLs."""
  inviteHash: String!

  """The issue estimation type to use."""
  issueEstimationType: String!

  """Whether issues without priority should be sorted first."""
  issueOrderingNoPriorityFirst: Boolean!

  """Whether to allow zeros in issues estimates."""
  issueEstimationAllowZero: Boolean!

  """Whether to add additional points to the estimate scale."""
  issueEstimationExtended: Boolean!

  """What to use as an default estimate for unestimated issues."""
  defaultIssueEstimate: Float!

  """Whether triage mode is enabled for the team or not."""
  triageEnabled: Boolean!

  """
  The default workflow state into which issues are set when they are opened by team members.
  """
  defaultIssueState: WorkflowState

  """
  The default template to use for new issues created by members of the team.
  """
  defaultTemplateForMembers: Template

  """
  The id of the default template to use for new issues created by members of the team.
  """
  defaultTemplateForMembersId: String @deprecated(reason: "Use defaultTemplateForMembers instead")

  """
  The default template to use for new issues created by non-members of the team.
  """
  defaultTemplateForNonMembers: Template

  """
  The id of the default template to use for new issues created by non-members of the team.
  """
  defaultTemplateForNonMembersId: String @deprecated(reason: "Use defaultTemplateForNonMembers instead")

  """
  The workflow state into which issues are set when they are opened by non-team
  members or integrations if triage is enabled.
  """
  triageIssueState: WorkflowState

  """Whether the team is private or not."""
  private: Boolean!

  """
  The workflow state into which issues are moved when a PR has been opened as draft.
  """
  draftWorkflowState: WorkflowState

  """
  The workflow state into which issues are moved when a PR has been opened.
  """
  startWorkflowState: WorkflowState

  """
  The workflow state into which issues are moved when a review has been requested for the PR.
  """
  reviewWorkflowState: WorkflowState

  """
  The workflow state into which issues are moved when a PR has been merged.
  """
  mergeWorkflowState: WorkflowState

  """Whether to group recent issue history entries."""
  groupIssueHistory: Boolean!

  """Whether to send new issue notifications to Slack."""
  slackNewIssue: Boolean!

  """Whether to send new issue comment notifications to Slack."""
  slackIssueComments: Boolean!

  """Whether to send new issue status updates to Slack."""
  slackIssueStatuses: Boolean!

  """
  Period after which issues are automatically closed in months. Null/undefined means disabled.
  """
  autoClosePeriod: Float

  """
  The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state.
  """
  autoCloseStateId: String

  """
  Period after which automatically closed and completed issues are automatically archived in months.
  """
  autoArchivePeriod: Float!

  """
  The workflow state into which issues are moved when they are marked as a
  duplicate of another issue. Defaults to the first canceled state.
  """
  markedAsDuplicateWorkflowState: WorkflowState

  """Calendar feed URL (iCal) for cycles."""
  cycleCalenderUrl: String!

  """Issues associated with the team."""
  issues(
    """[Alpha] Filter returned issues."""
    filter: IssueFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """Cycles associated with the team."""
  cycles(
    """[Alpha] Filter returned cycles."""
    filter: CycleFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CycleConnection!

  """Team's currently active cycle."""
  activeCycle: Cycle

  """Users who are members of this team."""
  members(
    """[Alpha] Filter returned users."""
    filter: UserFilter

    """Should query return disabled/suspended users (default: false)."""
    includeDisabled: Boolean

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): UserConnection!

  """
  Memberships associated with the team. For easier access of the same data, use `members` query.
  """
  memberships(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TeamMembershipConnection!

  """Projects associated with the team."""
  projects(
    """[Alpha] Filter returned projects."""
    filter: ProjectFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectConnection!

  """The states that define the workflow associated with the team."""
  states(
    """[Alpha] Filter returned workflow states."""
    filter: WorkflowStateFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): WorkflowStateConnection!

  """Templates associated with the team."""
  templates(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TemplateConnection!

  """Labels associated with the team."""
  labels(
    """[Alpha] Filter returned issue labels."""
    filter: IssueLabelFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueLabelConnection!

  """Webhooks associated with the team."""
  webhooks(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): WebhookConnection!
}

type TeamConnection {
  edges: [TeamEdge!]!
  nodes: [Team!]!
  pageInfo: PageInfo!
}

input TeamCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The name of the team."""
  name: String!

  """The description of the team."""
  description: String

  """
  The key of the team. If not given, the key will be generated based on the name of the team.
  """
  key: String

  """The icon of the team."""
  icon: String

  """The color of the team."""
  color: String

  """The organization associated with the team."""
  organizationId: String

  """Whether the team uses cycles."""
  cyclesEnabled: Boolean

  """The day of the week that a new cycle starts."""
  cycleStartDay: Float

  """The duration of each cycle in weeks."""
  cycleDuration: Int

  """The cooldown time after each cycle in weeks."""
  cycleCooldownTime: Int

  """Auto assign started issues to current active cycle setting."""
  cycleIssueAutoAssignStarted: Boolean

  """Auto assign completed issues to current active cycle setting."""
  cycleIssueAutoAssignCompleted: Boolean

  """Only allow issues issues with cycles in Active Issues."""
  cycleLockToActive: Boolean

  """How many upcoming cycles to create."""
  upcomingCycleCount: Float

  """Whether triage mode is enabled for the team."""
  triageEnabled: Boolean

  """The timezone of the team."""
  timezone: String

  """Whether issues without priority should be sorted first."""
  issueOrderingNoPriorityFirst: Boolean

  """The issue estimation type to use."""
  issueEstimationType: String

  """Whether to allow zeros in issues estimates."""
  issueEstimationAllowZero: Boolean

  """Whether to add additional points to the estimate scale."""
  issueEstimationExtended: Boolean

  """What to use as an default estimate for unestimated issues."""
  defaultIssueEstimate: Float

  """Whether to group recent issue history entries."""
  groupIssueHistory: Boolean

  """The identifier of the default template for members of this team."""
  defaultTemplateForMembersId: String

  """The identifier of the default template for non-members of this team."""
  defaultTemplateForNonMembersId: String

  """Internal. Whether the team is private or not."""
  private: Boolean

  """Period after which issues are automatically closed, in months."""
  autoClosePeriod: Float

  """The canceled workflow state which auto closed issues will be set to."""
  autoCloseStateId: String

  """
  Period after which closed and completed issues are automatically archived, in months. 0 means disabled.
  """
  autoArchivePeriod: Float

  """
  The workflow state into which issues are moved when they are marked as a duplicate of another issue.
  """
  markedAsDuplicateWorkflowStateId: String
}

type TeamEdge {
  node: Team!

  """Used in `before` and `after` args"""
  cursor: String!
}

"""[Alpha] Project filtering options."""
input TeamFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the team name."""
  name: StringComparator

  """Comparator for the team key."""
  key: StringComparator

  """Comparator for the team description."""
  description: NullableStringComparator

  """Filters that the teams issues must satisfy."""
  issues: IssueCollectionFilter

  """Compound filters, all of which need to be matched by the team."""
  and: [TeamFilter!]

  """Compound filters, one of which need to be matched by the team."""
  or: [TeamFilter!]
}

"""Defines the membership of a user to a team."""
type TeamMembership implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The user that the membership is associated with."""
  user: User!

  """The team that the membership is associated with."""
  team: Team!

  """Whether the user is the owner of the team"""
  owner: Boolean
}

type TeamMembershipConnection {
  edges: [TeamMembershipEdge!]!
  nodes: [TeamMembership!]!
  pageInfo: PageInfo!
}

input TeamMembershipCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The identifier of the user associated with the membership."""
  userId: String!

  """The identifier of the team associated with the membership."""
  teamId: String!

  """Internal. Whether the user is the owner of the team."""
  owner: Boolean
}

type TeamMembershipEdge {
  node: TeamMembership!

  """Used in `before` and `after` args"""
  cursor: String!
}

type TeamMembershipPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The team membership that was created or updated."""
  teamMembership: TeamMembership

  """Whether the operation was successful."""
  success: Boolean!
}

input TeamMembershipUpdateInput {
  """Internal. Whether the user is the owner of the team."""
  owner: Boolean!
}

type TeamPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The team that was created or updated."""
  team: Team

  """Whether the operation was successful."""
  success: Boolean!
}

input TeamUpdateInput {
  """The name of the team."""
  name: String

  """The description of the team."""
  description: String

  """The key of the team."""
  key: String

  """The icon of the team."""
  icon: String

  """The color of the team."""
  color: String

  """Whether the team uses cycles."""
  cyclesEnabled: Boolean

  """The day of the week that a new cycle starts."""
  cycleStartDay: Float

  """The duration of each cycle in weeks."""
  cycleDuration: Int

  """The cooldown time after each cycle in weeks."""
  cycleCooldownTime: Int

  """Auto assign started issues to current active cycle setting."""
  cycleIssueAutoAssignStarted: Boolean

  """Auto assign completed issues to current active cycle setting."""
  cycleIssueAutoAssignCompleted: Boolean

  """Only allow issues with cycles in Active Issues."""
  cycleLockToActive: Boolean

  """Whether the first cycle should start in the current or the next week."""
  cycleEnabledStartWeek: String

  """How many upcoming cycles to create."""
  upcomingCycleCount: Float

  """The timezone of the team."""
  timezone: String

  """Whether issues without priority should be sorted first."""
  issueOrderingNoPriorityFirst: Boolean

  """The issue estimation type to use."""
  issueEstimationType: String

  """Whether to allow zeros in issues estimates."""
  issueEstimationAllowZero: Boolean

  """Whether to add additional points to the estimate scale."""
  issueEstimationExtended: Boolean

  """What to use as an default estimate for unestimated issues."""
  defaultIssueEstimate: Float

  """
  The workflow state into which issues are moved when a draft PR has been opened.
  """
  draftWorkflowStateId: String

  """
  The workflow state into which issues are moved when a PR has been opened.
  """
  startWorkflowStateId: String

  """
  The workflow state into which issues are moved when a review has been requested for the PR.
  """
  reviewWorkflowStateId: String

  """
  The workflow state into which issues are moved when a PR has been merged.
  """
  mergeWorkflowStateId: String

  """Whether to send new issue notifications to Slack."""
  slackNewIssue: Boolean

  """Whether to send new issue comment notifications to Slack."""
  slackIssueComments: Boolean

  """Whether to send issue status update notifications to Slack."""
  slackIssueStatuses: Boolean

  """Whether to group recent issue history entries."""
  groupIssueHistory: Boolean

  """The identifier of the default template for members of this team."""
  defaultTemplateForMembersId: String

  """The identifier of the default template for non-members of this team."""
  defaultTemplateForNonMembersId: String

  """Whether the team is private or not."""
  private: Boolean

  """Whether triage mode is enabled for the team."""
  triageEnabled: Boolean

  """Default status for newly created issues."""
  defaultIssueStateId: String

  """Period after which issues are automatically closed, in months."""
  autoClosePeriod: Float

  """The canceled workflow state which auto closed issues will be set to."""
  autoCloseStateId: String

  """
  Period after which closed and completed issues are automatically archived, in months.
  """
  autoArchivePeriod: Float

  """
  The workflow state into which issues are moved when they are marked as a duplicate of another issue.
  """
  markedAsDuplicateWorkflowStateId: String
}

"""A template object used for creating entities faster."""
type Template implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The entity type this template is for."""
  type: String!

  """The name of the template."""
  name: String!

  """Template description."""
  description: String

  """Template data."""
  templateData: JSON!

  """
  The organization that the template is associated with. If null, the template is associated with a particular team.
  """
  organization: Organization

  """
  The team that the template is associated with. If null, the template is global to the workspace.
  """
  team: Team

  """The user who created the template."""
  creator: User
}

type TemplateConnection {
  edges: [TemplateEdge!]!
  nodes: [Template!]!
  pageInfo: PageInfo!
}

input TemplateCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The template type, e.g. 'issue'."""
  type: String!

  """
  The identifier or key of the team associated with the template. If not given,
  the template will be shared across all teams.
  """
  teamId: String

  """The template name."""
  name: String!

  """The template description."""
  description: String

  """
  The template data as JSON encoded attributes of the type of entity, such as an issue.
  """
  templateData: JSON!
}

type TemplateEdge {
  node: Template!

  """Used in `before` and `after` args"""
  cursor: String!
}

type TemplatePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The template that was created or updated."""
  template: Template!

  """Whether the operation was successful."""
  success: Boolean!
}

input TemplateUpdateInput {
  """The template name."""
  name: String

  """The template description."""
  description: String

  """
  The identifier or key of the team associated with the template. If set to
  null, the template will be shared across all teams.
  """
  teamId: String

  """
  The template data as JSON encoded attributes of the type of entity, such as an issue.
  """
  templateData: JSON
}

"""
Represents a date in ISO 8601 format. Accepts shortcuts like `2021` to represent
midnight Fri Jan 01 2021. Also accepts ISO 8601 durations strings which are
added to the current date to create the represented date (e.g '-P2W1D'
represents the date that was two weeks and 1 day ago) 
"""
scalar TimelessDate

"""Comparator for timeless dates."""
input TimelessDateComparator {
  """Equals constraint."""
  eq: TimelessDate

  """Not-equals constraint."""
  neq: TimelessDate

  """In-array constraint."""
  in: [TimelessDate!]

  """Not-in-array constraint."""
  nin: [TimelessDate!]

  """
  Less-than constraint. Matches any values that are less than the given value.
  """
  lt: TimelessDate

  """
  Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
  """
  lte: TimelessDate

  """
  Greater-than constraint. Matches any values that are greater than the given value.
  """
  gt: TimelessDate

  """
  Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
  """
  gte: TimelessDate
}

input TokenUserAccountAuthInput {
  """The email which to login via the magic login code."""
  email: String!

  """The magic login code."""
  token: String!

  """The timezone of the user's browser."""
  timezone: String!

  """The identifiers of the teams to auto-join."""
  teamIdsToJoin: [String!]
}

"""How trashed models should be loaded."""
enum TrashOptionType {
  includeTrash
  excludeTrash
  trashOnly
}

input UpdateOrganizationInput {
  """The name of the organization."""
  name: String

  """The logo of the organization."""
  logoUrl: String

  """The URL key of the organization."""
  urlKey: String

  """
  How git branches are formatted. If null, default formatting will be used.
  """
  gitBranchFormat: String

  """
  Whether the Git integration linkback messages should be sent for private repositories.
  """
  gitLinkbackMessagesEnabled: Boolean

  """
  Whether the Git integration linkback messages should be sent for public repositories.
  """
  gitPublicLinkbackMessagesEnabled: Boolean

  """Whether the organization is using project milestones."""
  roadmapEnabled: Boolean

  """Whether the organization is using project milestones."""
  reducedPersonalInformation: Boolean

  """Linear Preview feature flags"""
  linearPreviewFlags: JSONObject

  """List of services that are allowed to be used for login."""
  allowedAuthServices: [String!]
}

input UpdateUserInput {
  """The name of the user."""
  name: String

  """The display name of the user."""
  displayName: String

  """The avatar image URL of the user."""
  avatarUrl: String

  """Whether the user account is active."""
  active: Boolean

  """Reason for deactivation."""
  disableReason: String

  """Whether the user account has admin privileges."""
  admin: Boolean

  """The user description or a short bio."""
  description: String

  """The emoji part of the user status."""
  statusEmoji: String

  """The label part of the user status."""
  statusLabel: String

  """When the user status should be cleared."""
  statusUntilAt: DateTime

  """The local timezone of the user."""
  timezone: String
}

"""Object representing Google Cloud upload policy, plus additional data."""
type UploadFile {
  """The filename."""
  filename: String!

  """The content type."""
  contentType: String!

  """The size of the uploaded file."""
  size: Int!

  """The signed URL the for the uploaded file. (assigned automatically)"""
  uploadUrl: String!

  """The asset URL for the uploaded file. (assigned automatically)"""
  assetUrl: String!
  metaData: JSON
  headers: [UploadFileHeader!]!
}

type UploadFileHeader {
  """Upload file header key."""
  key: String!

  """Upload file header value."""
  value: String!
}

type UploadPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Object describing the file to be uploaded."""
  uploadFile: UploadFile

  """Whether the operation was successful."""
  success: Boolean!
}

"""A user that has access to the the resources of an organization."""
type User implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The user's full name."""
  name: String!

  """The user's display (nick) name. Unique within each organization."""
  displayName: String!

  """The user's email address."""
  email: String!

  """An URL to the user's avatar image."""
  avatarUrl: String

  """Reason why is the account disabled."""
  disableReason: String

  """Unique hash for the user to be used in invite URLs."""
  inviteHash: String!

  """A short description of the user, either its title or bio."""
  description: String

  """The emoji to represent the user current status."""
  statusEmoji: String

  """The label of the user current status."""
  statusLabel: String

  """A date at which the user current status should be cleared."""
  statusUntilAt: DateTime

  """The local timezone of the user."""
  timezone: String

  """Organization the user belongs to."""
  organization: Organization!

  """
  The last time the user was seen online. If null, the user is currently online.
  """
  lastSeen: DateTime

  """
  Whether the user is a guest in the workspace and limited to accessing a subset of teams.
  """
  guest: Boolean!

  """Whether the user account is active or disabled (suspended)."""
  active: Boolean!

  """User's profile URL."""
  url: String!

  """Issues assigned to the user."""
  assignedIssues(
    """[Alpha] Filter returned issues."""
    filter: IssueFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """Issues created by the user."""
  createdIssues(
    """[Alpha] Filter returned issues."""
    filter: IssueFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """Number of issues created."""
  createdIssueCount: Int!

  """Teams the user is part of."""
  teams(
    """[Alpha] Filter returned teams."""
    filter: TeamFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TeamConnection!

  """
  Memberships associated with the user. For easier access of the same data, use `teams` query.
  """
  teamMemberships(
    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TeamMembershipConnection!

  """Whether the user is the currently authenticated user."""
  isMe: Boolean!

  """Whether the user is an organization administrator."""
  admin: Boolean!
}

"""A user account."""
type UserAccount {
  """The models identifier."""
  id: ID!

  """The time at which the model was created."""
  createdAt: DateTime!

  """The time at which the model was updated."""
  updatedAt: DateTime!

  """The time at which the model was archived."""
  archivedAt: DateTime

  """The user's name."""
  name: String

  """The user's email address."""
  email: String!

  """The authentication service used to create the account."""
  service: String!

  """Users belonging to the account."""
  users: [User!]!
}

type UserAdminPayload {
  """Whether the operation was successful."""
  success: Boolean!
}

"""
Public information of the OAuth application, plus whether the application has been authorized for the given scopes.
"""
type UserAuthorizedApplication {
  """OAuth application's client ID."""
  clientId: String!

  """Application name."""
  name: String!

  """Information about the application."""
  description: String

  """Name of the developer."""
  developer: String!

  """Url of the developer (homepage or docs)."""
  developerUrl: String!

  """Image of the application."""
  imageUrl: String

  """Whether the user has authorized the application for the given scopes."""
  isAuthorized: Boolean!

  """Whether the application was created by Linear."""
  createdByLinear: Boolean!

  """Whether or not webhooks are enabled for the application."""
  webhooksEnabled: Boolean!
}

type UserConnection {
  edges: [UserEdge!]!
  nodes: [User!]!
  pageInfo: PageInfo!
}

type UserEdge {
  node: User!

  """Used in `before` and `after` args"""
  cursor: String!
}

"""[Alpha] User filtering options."""
input UserFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the user's name."""
  name: StringComparator

  """Comparator for the user's display name."""
  displayName: StringComparator

  """Comparator for the user's email."""
  email: StringComparator

  """Comparator for the user's activity status."""
  active: BooleanComparator

  """Filters that the users assigned issues must satisfy."""
  assignedIssues: IssueCollectionFilter

  """Compound filters, all of which need to be matched by the user."""
  and: [UserFilter!]

  """Compound filters, one of which need to be matched by the user."""
  or: [UserFilter!]

  """Comparator for the user's admin status."""
  admin: BooleanComparator

  """
  Filter based on the currently authenticated user. Set to true to filter for
  the authenticated user, false for any other user.
  """
  isMe: BooleanComparator
}

"""The types of flags that the user can have."""
enum UserFlagType {
  completedOnboarding
  desktopInstalled
  desktopDownloadToastDismissed
  emptyBacklogDismissed
  emptyCustomViewsDismissed
  emptyActiveIssuesDismissed
  emptyMyIssuesDismissed
  triageWelcomeDismissed
  cycleWelcomeDismissed
  projectWelcomeDismissed
  projectBacklogWelcomeDismissed
  analyticsWelcomeDismissed
  figmaPromptDismissed
  issueMovePromptCompleted
  migrateThemePreference
  listSelectionTip
  canPlaySnake
  canPlayTetris
  importBannerDismissed
  dueDateShortcutMigration
  slackCommentReactionTipShown
  all
}

"""Operations that can be applied to UserFlagType"""
enum UserFlagUpdateOperation {
  incr
  decr
  clear
  lock
}

type UserPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The user that was created or updated."""
  user: User

  """Whether the operation was successful."""
  success: Boolean!
}

"""The different permission roles available to users on an organization"""
enum UserRoleType {
  admin
  guest
  user
}

"""The settings of a user as a JSON object."""
type UserSettings implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The notification channel settings the user has selected."""
  notificationPreferences: JSONObject!

  """The email types the user has unsubscribed from."""
  unsubscribedFrom: [String!]!

  """The user associated with these settings."""
  user: User!
}

type UserSettingsFlagPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The flag key which was updated."""
  flag: String!

  """The flag value after update."""
  value: Int!

  """Whether the operation was successful."""
  success: Boolean!
}

type UserSettingsFlagsResetPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type UserSettingsPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The user's settings."""
  userSettings: UserSettings!

  """Whether the operation was successful."""
  success: Boolean!
}

input UserSettingsUpdateInput {
  """The user's settings."""
  settings: String

  """The types of emails the user has unsubscribed from."""
  unsubscribedFrom: [String!]

  """The user's notification preferences."""
  notificationPreferences: JSONObject
}

type UserSubscribeToNewsletterPayload {
  """Whether the operation was successful."""
  success: Boolean!
}

"""A universally unique identifier as specified by RFC 4122."""
scalar UUID

"""View preferences."""
type ViewPreferences implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The view preference type."""
  type: String!

  """The view type."""
  viewType: String!
}

input ViewPreferencesCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """
  The type of view preferences (either user or organization level preferences).
  """
  type: ViewPreferencesType!

  """The view type of the view preferences are associated with."""
  viewType: ViewType!

  """View preferences object."""
  preferences: JSONObject!

  """The team these view preferences are associated with."""
  teamId: String

  """The project these view preferences are associated with."""
  projectId: String

  """The label these view preferences are associated with."""
  labelId: String

  """The user profile these view preferences are associated with."""
  userId: String

  """The cycle these view preferences are associated with."""
  cycleId: String

  """The custom view these view preferences are associated with."""
  customViewId: String
}

type ViewPreferencesPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The view preferences entity being mutated."""
  viewPreferences: ViewPreferences!

  """Whether the operation was successful."""
  success: Boolean!
}

"""
The type of view preferences (either user or organization level preferences).
"""
enum ViewPreferencesType {
  organization
  user
}

input ViewPreferencesUpdateInput {
  """View preferences."""
  preferences: JSONObject!
}

"""The client view this custom view is targeting."""
enum ViewType {
  inbox
  myIssues
  userProfile
  board
  completedCycle
  cycle
  project
  label
  triage
  activeIssues
  backlog
  allIssues
  customView
  roadmap
  roadmapAll
  roadmapClosed
  roadmapBacklog
  projects
  projectsAll
  projectsBacklog
  projectsClosed
  search
  archive
}

"""A webhook used to send HTTP notifications over data updates"""
type Webhook implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """Webhook label"""
  label: String!

  """Webhook URL"""
  url: String

  """Whether the Webhook is enabled."""
  enabled: Boolean!

  """
  The team that the webhook is associated with. If null, the webhook is
  associated with all public teams of the organization.
  """
  team: Team

  """
  Whether the Webhook is enabled for all public teams, including teams created after the webhook was created.
  """
  allPublicTeams: Boolean!

  """The user who created the webhook."""
  creator: User

  """Secret token for verifying the origin on the recipient side."""
  secret: String

  """The resource types this webhook is subscribed to."""
  resourceTypes: [String!]!
}

type WebhookConnection {
  edges: [WebhookEdge!]!
  nodes: [Webhook!]!
  pageInfo: PageInfo!
}

input WebhookCreateInput {
  """Label for the webhook."""
  label: String

  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """Whether this webhook is enabled."""
  enabled: Boolean = true

  """An optional secret token used to sign the webhook payload."""
  secret: String

  """The URL that will be called on data changes."""
  url: String!

  """List of resources the webhook should subscribe to."""
  resourceTypes: [String!]!

  """The identifier or key of the team associated with the Webhook."""
  teamId: String

  """Whether this webhook is enabled for all public teams."""
  allPublicTeams: Boolean
}

type WebhookEdge {
  node: Webhook!

  """Used in `before` and `after` args"""
  cursor: String!
}

type WebhookPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The webhook entity being mutated."""
  webhook: Webhook!

  """Whether the operation was successful."""
  success: Boolean!
}

input WebhookUpdateInput {
  """Label for the webhook."""
  label: String

  """An optional secret token used to sign the Webhook payload."""
  secret: String

  """Whether this webhook is enabled."""
  enabled: Boolean

  """The URL that will be called on data changes."""
  url: String

  """List of resources the webhook should subscribe to."""
  resourceTypes: [String!]
}

"""A state in a team workflow."""
type WorkflowState implements Node {
  """The unique identifier of the entity."""
  id: ID!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The last time at which the entity was updated. This is the same as the creation time if the
      entity hasn't been updated after creation.
  """
  updatedAt: DateTime!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The state's name."""
  name: String!

  """The state's UI color as a HEX string."""
  color: String!

  """Description of the state."""
  description: String

  """The position of the state in the team flow."""
  position: Float!

  """The type of the state."""
  type: String!

  """The team to which this state belongs to."""
  team: Team!

  """Issues belonging in this state."""
  issues(
    """[Alpha] Filter returned issues."""
    filter: IssueFilter

    """A cursor to be used with last for backward pagination."""
    before: String

    """A cursor to be used with first for forward pagination"""
    after: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!
}

type WorkflowStateConnection {
  edges: [WorkflowStateEdge!]!
  nodes: [WorkflowState!]!
  pageInfo: PageInfo!
}

input WorkflowStateCreateInput {
  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """The workflow type."""
  type: String!

  """The name of the state."""
  name: String!

  """The color of the state."""
  color: String!

  """The description of the state."""
  description: String

  """The position of the state."""
  position: Float

  """The team associated with the state."""
  teamId: String!
}

type WorkflowStateEdge {
  node: WorkflowState!

  """Used in `before` and `after` args"""
  cursor: String!
}

"""[Alpha] Workflow state filtering options."""
input WorkflowStateFilter {
  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the workflow state name."""
  name: StringComparator

  """Comparator for the workflow state description."""
  description: StringComparator

  """Comparator for the workflow state position."""
  position: NumberComparator

  """Comparator for the workflow state type."""
  type: StringComparator

  """Filters that the workflow states team must satisfy."""
  team: TeamFilter

  """Filters that the workflow states issues must satisfy."""
  issues: IssueCollectionFilter

  """
  Compound filters, all of which need to be matched by the workflow state.
  """
  and: [WorkflowStateFilter!]

  """
  Compound filters, one of which need to be matched by the workflow state.
  """
  or: [WorkflowStateFilter!]
}

type WorkflowStatePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The state that was created or updated."""
  workflowState: WorkflowState!

  """Whether the operation was successful."""
  success: Boolean!
}

input WorkflowStateUpdateInput {
  """The name of the state."""
  name: String

  """The color of the state."""
  color: String

  """The description of the state."""
  description: String

  """The position of the state."""
  position: Float
}

"""Zendesk specific settings."""
type ZendeskSettings {
  """The subdomain of the Zendesk organization being connected."""
  subdomain: String!

  """The URL of the connected Zendesk organization."""
  url: String!

  """The ID of the Linear bot user."""
  botUserId: String!
}

input ZendeskSettingsInput {
  """The subdomain of the Zendesk organization being connected."""
  subdomain: String!

  """The URL of the connected Zendesk organization."""
  url: String!

  """The ID of the Linear bot user."""
  botUserId: String!
}

